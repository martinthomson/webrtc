<!DOCTYPE html>
<html>
  <head>
    <title>Realtime Peer-to-Peer Transport API</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
        === NOTA BENE ===
        For the three scripts below, if your spec resides on dev.w3 you can check them
        out in the same tree and use relative links so that they'll work offline,
      -->
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "ED",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "rt-transport",

      // if your specification has a subtitle that goes below the main
      // formal title, define it here
      subtitle   :  "Web API for establishing peer-to-peer transport",

      // if you wish the publication date to be other than today, set this
      // publishDate:  "2012-06-06",

      // if the specification's copyright date is a range of years, specify
      // the start date here:
      copyrightStart: "2012",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "https://github.com/martinthomson/webrtc/blob/master/realtime-transport.html",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
      { name: "Martin Thomson", url: "mailto:martin.thomson@gmail.com",
      company: "Microsoft", companyURL: "http://microsoft.com/" },
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      authors:  [
          { name: "Bernard Aboba", url: "mailto:bernard_aboba@hotmail.com",
            company: "Microsoft", companyURL: "http://microsoft.com/" },
      ],

      // name of the WG
      wg:           "WebRTC Working Group",

      // URI of the public WG page
      wgURI:        "http://www.w3.org/standards/techs/webrtc",

      // name (without the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-webrtc",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  ""
      };
    </script>
    <style type="text/css">
/* copied from pre.idl */
pre.pseudoidl:before {
    background: none repeat scroll 0 0 #90B8DE;
    color: #FFFFFF;
    content: "WebIDL";
    display: block;
    font-family: initial;
    font-weight: bold;
    margin: -1em 0 1em -1em;
    padding: 3px;
    width: 150px;
}
pre.pseudoidl {
    border-bottom: 1px solid #90B8DE;
    border-top: 1px solid #90B8DE;
    line-height: 120%;
    padding: 1em;
}
      </style>
    <script>
      // doesn't work because respec triggers idl processing on the class="idl".
      // made too difficult because respec passes a string rather than DOM
      function transformEnum(doc, content) {
          var name = 'enumname'; 
          var values = [ 'value1', 'value2' ];
          return '<pre class="idl">\n    enum <span class="idlInterfaceID">' + name + '</span> {\n' +
              '        ' + values.map(function(v) {
                  return '"<a href="widl-' + name + '-' + v + '">' + v + '</a>"';
              }).join(', ') + '\n    };\n</pre>\n' + content;
      }
    </script>
  </head>

  <body>
    <section id='abstract'>
      <p>
        This document describes how transport flows can be created in a browser. A transport flow is a construct that allows for bidirectional exchange of UDP packets. Chances are, these transport flows will be established between browsers.
      </p>
      <p>
        The flow of packets is encrypted and&mdash;depending on the selected protocol&mdash;the browser is able to ensure that the recipient is willing to receive the flow. Setup is mediated by the web application.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
        Establishing flows of realtime media to and from browsers requires a transport that is suited to this purpose.  This document describes how realtime transport flows can be created in a browser. A realtime transport flow is a construct that allows for bidirectional exchange of UDP packets.
      </p>
      <p>
        UDP and RTP [[!RFC3550]] provide the means for the delivery of time-sensitive media between peers.  This channel is secured using SRTP [[!RFC3711]] with key negotiation in signaling or through DTLS.
      </p>
      <p>Establishing flows of UDP through middleboxes such as Network Address Translators (NAT) or firewalls requires the use of techniques such as Interactive Connectivity Establishment (ICE) [[!RFC5245]].  The provided API describes primitives that enable the implementation of ICE, but do not require it other than requiring the consent mechanisms that it provides, which is critical to the security of the web.
      </p>
      <p>
        This API only deals with the creation of a secured transport between peers.  Sending media using this API is described in another document.
      </p>
    </section>

    <section>
      <h2>Requirements</h2>
      <p>
        The goal of this API is to:
        <ul>
          <li>establish a flow of packets between two peers suitable for carrying media</li>
          <li>provide confidentiality for communications</li>
          <li>ensure that excessive packets are not sent to unwilling hosts</li>
        </ul>
      </p>

      <section>
        <h3>Design Goals</h3>
        <p>
          It is possible to achieve the basic goals in a number of ways.  This design attempts to provide the maximum flexibility in the API, with minimal complexity.
        </p>
        <p>
          To that end, the API ensures that the browser contains as little of the implementation of the transport establishment code as possible.  This provides the using application more control over application logic.
        </p>
        <p>
          This API also reduces the amount of application state that the browser maintains.  This reduces the coupling of browser and application implementations, simplifies API interactions, gives applications greater control over browser behavior and enables the creation of more robust applications.  For example, a browser with less accumulated state can recover necessary state faster in the event of a reload than otherwise.
        </p>
      </section>

      <section>
        <h3>Non-Goals</h3>
        <p>
          It is not a goal of this API to provide an application with the ability to create minimal realtme applications.  Browser APIs rarely change once deployed, which means that a constraint imposed by an API is difficult to remove.  In complete contrast, applications on the web are able to evolve rapidly.  Moving the bulk of the necessary logic to application code ensures greater scope for innovation.  A simple set of basic primitives are better enablers.
        </p>

        <p>
          The successful creation of RTP streams requires signaling.  Subjecting that signaling to standardization would constrain how it manifests, limiting the flexibility of applications that use these APIs.
        </p>
      </section>
    </section>

    <section>
      <h2>Overview</h2>
      <p>
        Establishing realtime media transport requires the interaction of two objects:
        <ul>
          <li>
            The <code><a>RealtimePort</a></code> is the end point for a realtime transport.  This represents a UDP port, opened by the browser.  The RealtimePort encapsulates the functions necessary to perform an ICE negotiation [[!RFC5245]].  In ICE terms, a <code><a>RealtimePort</a></code> is a local candidate.
          </li>
          <li>
            The <code><a>RealtimeTransport</a></code> is a peer-to-peer bearer for secured media.  It binds a local <code><a>RealtimePort</a></code> to a remote <code><a>RealtimePort</a></code> and enables the bidirectional exchange of media packets.
          </li>
        </ul>
      </p>
      <p>
        In order to establish a transport between a local peer and remote peer, the following process is applied:
        <ol>
          <li>
            The local peer opens one or more realtime ports.
          </li>
          <li>
            The local peer then has to learn of the ports that its remote peer has opened.  This uses a signaling channel specific to the application.  For instance, a web application could use previously HTTP requests or Websockets connections for this purpose.
          </li>
          <li>
            A process of discovery is used to find a local and remote port pair (a candidate pair) that can exchange UDP packets.  One or more connectivity checks are made from different local ports toward different remote ports.  A successful connectivity check indicates that packets can reach the peer and that the peer consents to receive packets.  
          </li>
          <li>
            Finally, a realtime transport is established on the pair of ports.  A security context is established so that secured media packets are able to flow in both directions between peers.  Realtime media streams can then be added to the transport.
          </li>
        </ol>
      </p>
      <p>
        In the first step of this scenario one or more <code><a>RealtimePort</a></code> objects are created in different ways.  The browser allocates a local UDP port on each of the available network interfaces and returns these to the application.
      </p>
      <pre class="example">
    RealtimePort.openLocalPorts(function(ports) {
        signalingChannel.send('candidates', ports);
        localCandidates.push(ports);
    });
      </pre>
      <p>
        Each realtime port consists of an IP address, a port number, a username fragment and password.  This information is exchanged with the remote peer using whatever signaling mechanism is chosen by the application.
      </p>
      <p>
        Other forms of realtime port might be necessary for successful traversal of middleboxes like firewalls and NATs.  For instance, a relay port (i.e., relay candidate) uses a relay server to forward packets.  Because the relay server is publically reachable, many of the concerns with middlebox traversal do not apply to it, enabling communication in more challenging network conditions.
      </p>
      <pre class="example">
    RealtimePort.allocateRelay(relay, function(error, relayCandidates) {
        if (!error) {
            signalingChannel.send('candidate', relayCandidate);
        }
    });
      </pre>
      <p>
        Local and remote realtime ports are paired and connectivity checking is used for each pair to determine which ports can be used for exchanging packets.
      </p>
      <pre class="example">
    function receivePeerCandidates(remotePorts) {
        var candidatePairs = localCandidates.forEach(function(local) {
            return remotePorts.forEach(function(remote) {
                local.check(remote, checkCallback(local, remote));
            });
        });
    }
      </pre>
      <p>
        Of the successful connectivity checks, one or more pairs are selected.  The local port is then used to create a <code><a>RealtimeTransport</a></code>.
      </p>
      <pre class="example">
    function connectivityCheckSuccess(local, remote) {
        local.createTransport(remote, options, function(err, transport) {
            realtimeTransport = transport;
        });
    }
      </pre>
      <p>
        The resulting transport object can be used to securely exchange media with the peer.
      </p>
    </section>

    <section>
      <h2>Realtime Ports</h2>
      <p>
        A <code><dfn>RealtimePort</dfn></code> object represents an open UDP port.  The <code><a>RealtimePort</a></code> also encapsulates all the information necessary to find and use that port.
      </p>

      <section>
        <h3>The <code>RemoteRealtimePort</code> Object</h3>

        <p>
          The <code><dfn>RemoteRealtimePort</dfn></code> object is used to describe a remote realtime port.  It is a simple dictionary of values, sufficient to describe how to connect to a remote peer.
        </p>

        <dl title="dictionary RemoteRealtimePort" class="idl">
          <dt>DOMString ip</dt>
          <dd>
            The IP address (v4 or v6) for the realtime port.
          </dd>

          <dt>[EnforceRange] unsigned short port</dt>
          <dd>
            The UDP port number for the realtime port.
          </dd>

          <dt>DOMString ufrag</dt>
          <dd>
            The ICE username fragment for the port.
          </dd>
          <dt>DOMString username</dt>
          <dd>
            The username is used to specify the STUN <code>USERNAME</code> attribute explicitly.  If present, this parameter is used in preference to the username fragment.  See <a>server reflexive address</a>es for an explanation of this parameter.
          </dd>

          <dt>DOMString pwd</dt>
          <dd>
            The ICE password for the candidate.  This should be set unless this is being used to describe a STUN or TURN server that doesn't require authentication.
          </dd>
        </dl>

      </section>

      <section>
        <h3>The <code>RealtimePort</code> Object</h3>
        
        <p>
          A local <code><a>RealtimePort</a></code> provides limited access to the browsers STUN [[!RFC5389]] implementation which provides a means to trigger connectivity checking, the gathering of server reflexive addresses and allocation of TURN relays.
        </p>

        <p>
          The application cannot select or alter the values chosen for local ports.  The browser MAY select any UDP port number, and MUST select values for ufrag and pwd that have sufficient random entropy that they cannot be easily guessed.  This guarantees that only entities that receive this information are able to successfully make a connectivity check.  It also allows peers to identify unique browsers.
        </p>

        <dl title="interface RealtimePort : EventTarget" class="idl">
          <dt>readonly attribute DOMString ip</dt>
          <dd>
            The IP address (v4 or v6) for the realtime port.
          </dd>

          <dt>readonly attribute unsigned short port</dt>
          <dd>
            The UDP port number for the realtime port.
          </dd>

          <dt>readonly attribute DOMString ufrag</dt>
          <dd>
            The ICE username fragment for the port.
          </dd>

          <dt>readonly attribute DOMString pwd</dt>
          <dd>
            The ICE password for the port.
          </dd>

          <dt>static void openLocalPorts (RealtimePortCallback callback)</dt>
          <dd>
            Open ports on the local host.  One port is opened for each network interface on the host.  Calls the provided callback when complete.
          </dd>

          <dt>static void allocateRelay (TurnServer turnServer, RealtimePortCallback callback)</dt>
          <dd>
            <a href="allocateRelay">Allocate a relay port on a TURN server</a> using a newly created local base.
          </dd>
          <dt>void allocateRelay (TurnServer turnServer, RelayCallback callback)</dt>
          <dd>
            <a href="allocateRelay">Allocate a relay port on a TURN server</a> over UDP using this local realtime port as the base.
          </dd>
          
          <dt>[TreatNonCallableAsNull] attribute EventHandler? onnetworkchange</dt>
          <dd>
            An event handler for being informed of <a href="#networkchange">changes to network connectivity</a>.  <b>Note</b>: This is a candidate for moving to <code>navigator</code> or even the <a href="http://www.w3.org/TR/netinfo-api/">network information API</a>.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onchecksent</dt>
          <dd>
            Called when a <a href="#checking">connectivity check</a> is sent to a remote peer.  The event passed MUST NOT include the STUN Binding request.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onchecksuccess</dt>
          <dd>
            Called when a valid <a href="#checking">connectivity check</a> response is received from a remote peer.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onremotecheck</dt>
          <dd>
            Called when a remote peer <a href="#serving">successfully performs a connectivity check</a> against this port.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute EventHandler? onclose</dt>
          <dd>
            Invoked when the realtime port is closed.
          </dd>

          <dt>readonly attribute boolean open</dt>
          <dd>
            Whether the port is open and can be used.  This attribute is <code>true</code> when the object is passed to the application and <code>false</code> after the <a>close</a> method is invoked.
          </dd>

          <dt>long check (RemoteRealtimePort remote, optional StunAttribute... attributes)</dt>
          <dd>
            Perform a <a href="#checking">connectivity check</a> on the remote port.  Returns a handle on the check that can be used to <a href="#widl-RealtimePort-cancelCheck">cancel</a> it.
          </dd>

          <dt>void cancelCheck (long checkHandle)</dt>
          <dd>
            Cancel an outstanding or enqueued connectivity check.  This guarantees that a <code><a>onchecksuccess</a></code> event is never triggered for the specified check.
          </dd>

          <dt>boolean status (RemoteRealtimePort remoteRealtimePort)</dt>
          <dd>
            Query the status of a particular remote port with respect to this port.  Returns <code>true</code> iff the remote port was successfully checked recently.  The specific time is based on the browser's configured consent expiration timer.
          </dd>

          <dt>void close ()</dt>
          <dd>
            Closes the port and any associated open transports that use the port.
          </dd>
        </dl>

        <section>
          <h4>The <code>RealtimePortCallback</code> Callback</h4>
          <p>
            The <code><dfn>RealtimePortCallback</dfn></code> callback function is passed to <code><a>openLocalPorts</a></code> or <code><a>allocateRelay</a></code>.   When the port is either successfully opened, or opening fails, the callback is invoked.  Opening local ports cannot fail.  Allocating a TURN relay port creates a single port.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-RealtimePortCallback" class="idlCallback">callback <span class="idlDictionaryID">RealtimePortCallback</span> = void (<span class="idlParamType">DOMString?</span> <span class="idlParamName">error</span>, <span class="idlParamType">sequence&lt;<a class="idlType" href="#idl-def-RealtimePort">RealtimePort</a>></span> <span class="idlParamName">ports</span>);</span>
          </pre>
          <p>
            The error parameter is set to <code>null</code> unless the allocation fails, in which case it contains a <code>DOMString</code> that explains the reasons for the error.  (Ed: Need to specify error code values here.)
          </p>
        </section>
        
        <section>
          <h4>The <code>ConnectivityCheckEventHandler</code> Callback Function</h4>

          <p>
            This callback is invoked with an event whenever a connectivity check event occurs.  This is tied to the following events:
            <ul>
              <li>
                <b><code>onremotecheck</code></b>&mdash;when a valid connectivity check is made by a remote peer
              </li>
              <li>
                <b><code>onchecksent</code></b>&mdash;when a connectivity check is made by the browser
              </li>
              <li>
                <b><code>onchecksuccess</code></b>&mdash;when a connectivity check succeeds
              </li>
            </ul>
          </p>
          <pre class="pseudoidl">
<span id="idl-def-ConnectivityCheckEventHandler" class="idlCallback">callback <span class="idlDictionaryID">ConnectivityCheckEventHandler</span> = void (<span class="idlParamType"><a class="idlType" href="#idl-def-ConnectivityCheckEvent">ConnectivityCheckEvent</a></span> <span class="idlParamName">event</span>);</span>
          </pre>
        </section>

        <section>
          <h4>The <code>ConnectivityCheckEvent</code> Interface</h4>

          <p>
            The event object passed to the <code>ConnectivityCheckEventHandler</code> includes a target of the local port, the remote port and information on the STUN Binding request and Binding response messages that triggered the event.  
          </p>
          <p>
            The <code>onchecksent</code> event does not include either STUN message because revealing the STUN transaction identifier chosen by the browser could allow a web attacker to spoof a response.
          </p>

        <dl title="interface ConnectivityCheckEvent : Event" class="idl">
          <dt>attribute RemoteRealtimePort remote</dt>
          <dd>
            This identifies the remote port involved in this connectivity check.  For incoming checks, the remote port information only includes <code>ip</code> and <code>port</code>.
          </dd>
          
          <dt>attribute StunBinding? request</dt>
          <dd>
            For the <code>onchecksuccess</code> and <code>onremotecheck</code> events, this includes the STUN Binding request that was respectively sent or received.  For the <code>onchecksent</code> event, this attribute is <code>null</code>.
          </dd>

          <dt>attribute StunBinding? response</dt>
          <dd>
            For the <code>onchecksuccess</code> and <code>onremotecheck</code> events, this includes the STUN Binding response that was respectively received or sent.  For the <code>onchecksent</code> event, this attribute is <code>null</code>.
          </dd>
        </dl>
        </section>
      </section>
      
      <section>
        <h3><code>RealtimePort</code> Lifecycle</h3>
        <p>
          A local <a>RealtimePort</a> is created by the browser in response to a call to <code><a href="#widl-RealtimePort-openLocalPorts">openLocalPorts</a>(<var>callback</var>)</code> or <code><a href="#widl-RealtimePort-allocateRelay-static-void-TurnServer-turnServer-RealtimePortCallback-callback">allocateRelay</a>(<var>callback</var>)</code>.  Each RealtimePort is given to the application with the open attribute set to true. 
        </p>

        <section id="openLocalPorts">
          <h4>Opening Local Ports</h4>
          <p>
            Host-local ports (host candidates in ICE) are UDP ports that are opened on the local host.  These ports are opened by the browser in response to a call to <code><a>RealtimePort</a>.<a href="#widl-RealtimePort-openLocalPorts">openLocalPorts</a>(<var>callback</var>)</code>.
          </p>

          <p class="note">
            The username fragment and password used in ICE is normally global.  That is, the same values are shared for all candidates in the same session.  Browsers that wish to interoperate with non-browser peers SHOULD provide the same value for ufrag and pwd as a result of each request to open local ports.
          </p>
        </section>

        <section>
          <h4>Discovering Server Reflexive Addresses</h4>
          <p>
            A <dfn>server reflexive address</dfn> is the addressing information for a given port, as seen by a server.  The server reports the address that it sees when the browser sends it a packet.  Where there are network address translation (NAT) middleboxes between the browser and the server, this reveals the translated address at the NAT, a value that might be undetectable from the browser.
          </p>
          <p>
            Server reflexive addresses are gathered by making connectivity checks to STUN servers from a specific local realtime port.  The server provides the address that it sees in the <code>XOR-MAPPED-ADDRESS</code> attribute of the response.
          </p>
          <p>Using a server reflexive address ultimately results in packets arriving at the corresponding host-local port.  Therefore, server reflexive addresses do not require the creation of additional <code><a>RealtimePort</a></code> objects in the browser.
          </p>
          <p>
            The <a href="#checking">connectivity check</a> interface is used to send queries to STUN servers.  When querying a STUN server, the <code><a>RemoteRealtimePort</a></code> can include several variations on the set of included options:
            <ul>
              <li>
                An ICE-compatible <a href="#checking">connectivity check</a> is invoked by providing ICE username fragment and password parameters.  The STUN <code>USERNAME</code> attribute is populated by concatenating the remote username fragment (<code><var>remotePort</var>.ufrag</code>), a colon character (':') and the local username fragment.  The <code>MESSAGE-INTEGRITY</code> attribute is created using the remote password (<code><var>remotePort</var>.pwd</code>) as described in [[!RFC5389]].
              </li>
              <li>
                A <var>username</var> parameter can be provided in place of <var>ufrag</var>.  The browser uses the value of <var>username</var> for the STUN <code>USERNAME</code> attribute.  <code>MESSAGE-INTEGRITY</code> is filled as normal.
              </li>
              <li>
                Both <var>ufrag</var> and <var>username</var> can be omitted to suppress the inclusion of the <code>USERNAME</code> attribute.
              </li>
              <li>
                <var>pwd</var> can be omitted to suppress the inclusion of the <code>MESSAGE-INTEGRITY</code> attribute.
              </li>
            </ul>
          </p>
          <p>
            A port pair is only marked as having active consent if the ICE-compatible connectivity check is used.  This ensures that STUN servers cannot be bombarded with media from browsers.
          </p>
          <p>
            If long-term credentials are in use for the STUN server, as described in [[!RFC5389]], then the application is responsible for calculating the value of the password.
          </p>
        </section>

        <section id="allocateRelay">
          <h4>Allocating Relays</h4>
          <p>
            UDP relays are allocated by calling <code><a>RealtimePort</a>.<dfn>allocateRelay</dfn>(<var>turnServerRealtimePort</var>, <var>callback</var>[, <var>attributes</var>])</code>.  The browser performs a TURN [[!RFC5766]] relay allocation with the identified host and provides a relayed <code><a>RealtimePort</a></code> to the provided callback.
          </p>
          <p>
            A <var>turn</var> attribute can be set on the TURN server <code><a>RemoteRealtimePort</a></code> to select the transport used between the browser and TURN server.  The <var>turn</var> attribute takes one of three values: <code>udp</code>, <code>tcp</code>, or <code>tls</code>.  The browser uses UDP to communicate with the TURN server unless otherwise specified.  The <var>turn</var> attribute only determines the transport used between browser and TURN server; UDP is the only supported transport between the server and remote peers.
          </p>
          <p>
            Once the allocation has completed, the <var>callback</var> method is invoked.  An error parameter is set to an error code if the allocation fails.  An array containing a single <code><a>RealtimePort</a></code> parameter is provided if the allocation is successful.
          </p>
          <pre class="example">
    function createRelayCandidate() {
        var relay = { ip: '192.0.2.75', port: 7754, username: 'user', password: 'password1', turn: 'udp' };
        RealtimePort.allocateRelay(relay, function(error, relayCandidates) {
            if (error) {
                reportError(error);
            } else {
                signalingChannel.send('candidate', relayCandidate);
                scheduleConnectivityChecks(relayCandidate);
            }
        });
    }
          </pre>
          <p>
            In order to select a specific local candidate for the allocation of relays, the <code><a>allocateRelay</a></code> method can be called on a candidate instance.  This is only possible if the transport to the relay server is UDP.
          </p>
          <p>
            Application-selected attributes can be added to the allocation request, just as they can be added to <a href="#checking">connectivity checks</a>.
          </p>
          
          <dl title="dictionary TurnServer : RemoteRealtimePort" class="idl">
            <dt>TurnRelayTransport turn = "udp"</dt>
            <dd>
              The protocol to use for communication with a TURN relay.
            </dd>
          </dl>
          
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-TurnRelayTransport">TurnRelayTransport</a></span> {
    "<a href="#widl-TurnRelayTransport-udp">udp</a>", "<a href="#widl-TurnRelayTransport-tcp">tcp</a>", "<a href="#widl-TurnRelayTransport-tls">tls</a>"
};
          </pre>
          <!-- <dl title="[NoInterfaceObject] enum TurnRelayTransport" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-TurnRelayTransport-udp"><code>udp</code></dt>
            <dd>
              Use UDP transport between the browser and the TURN relay server.  This is the default value.
            </dd>

            <dt id="widl-TurnRelayTransport-tcp"><code>tcp</code></dt>
            <dd>
              Use TCP transport between the browser and the TURN relay server.
            </dd>

            <dt id="widl-TurnRelayTransport-tls"><code>tls</code></dt>
            <dd>
              Use TLS over TCP transport between the browser and the TURN relay server.
            </dd>
          </dl>
        </section>
        
        <section>
          <h4>Closing Realtime Ports</h4>
          <p>
            Realtime ports can be closed by calling <code><a href="#widl-RealtimePort-close">close</a>()</code>.  This sets the <var>open</var> attribute to false and closes any transports that use the port.   Any attempt to invoke methods on a closed <code><a>RealtimePort</a></code> triggers an exception, except for <code>status(<var>remotePort</var>)</code> that can harmlessly return <code>false</code>.
          </p>

          <p>
            Closing a realtime port does not prevent packets from arriving, though it stops them from being seen by applications and thus connectivity checks to these ports fail.  A well-behaved remote peer will eventually stop sending when connectivity checks fail.
          </p>
        </section>
      </section>

      <section>
        <h3>Connectivity Checking</h3>
        <p>
          To establish a bidirectional transport flow between peers, both are required to successfully complete one or more connectivity check requests.  Connectivity checks are used to open ports on NAT and firewall middleboxes, to validate end-to-end connectivity and to establish that the peer is willing to receive packets.
        </p>

        <section id="checking">
          <h4>Sending Connectivity Checks</h4>
          <p>
            Applications can request the sending of a STUN Binding request to perform a connectivity check or collect additional addressing information.  The browser performs a connectivity check by sending a STUN Binding request using <code><var>candidate</var>.<a>check</a>(<var>remotePort</var>, <var>callback</var>[, <var>attributes</var>])</code>.
          </p>
          <p>
            The browser invokes the callback function if the connectivity check successfully completes.  The STUN request and response messages are passed to the callback.
          </p>
          <p>
            Binding requests MUST be globally rate limited by the browser.  Any requests that cannot be immediately sent are enqueued.  A browser MAY limit the number of requests that it will enqueue; lower limits SHOULD be applied to individual origins to prevent origins from monopolizing access to this feature.
          </p>
          <p class="note">
            ICE specifies a rate limiting function that is based on the expected bandwidth of media.  Since this depends on information provided by a potential web attacker, this input cannot be used.  The browser MUST rate limit connectivity checks based only on information that cannot be influenced or altered by a web attacker.
          </p>
          <p>
            The browser is responsible for populating the STUN <code>USERNAME</code>, <code>MESSAGE-INTEGRITY</code> and <code>FINGERPRINT</code> attributes.  STUN attributes can be added or overwritten by including values in the optional <code><var>attributes</var></code> parameter.  STUN attributes specified in this manner are covered by the integrity check.  Attributes that would cause the STUN request to exceed its size limit cause an exception to be thrown.
          </p>
          <p>
            DOMString values for <code><a href="#widl-RemoteRealtimePort-ufrag">ufrag</a></code> and <code><a href="#widl-RemoteRealtimePort-pwd">pwd</a></code> are encoded using UTF-8 [[!UTF-8]] in Binding requests.
          </p>
          <p>
            Prior to the successful completion of a connectivity check, the browser MUST NOT reveal the transaction identifier to the application.  Knowing the transaction identifier of a STUN request prior to receiving a successful response would enable the spoofing of responses, potentially tricking the browser into sending media packets to an unwilling recipient.
          </p>
          <p>
            The browser MUST limit the time that an outstanding connectivity check remains valid.  However, the browser is not responsible for providing a callback when this timer expires.  The application is responsible for looking after its own timers.
          </p>
        </section>

        <section id="tracking">
          <h4>Tracking Valid Realtime Port Pairs</h4>
          <p>
            The browser is responsible for tracking valid remote realtime port pairs.  Any time that a locally originated connectivity check succeeds, the browser marks the pair of ports (local port + remote port) as valid.  The valid marking lasts for a fixed duration.  The browser SHOULD keep a port pair valid for 40 seconds.
          </p>
          <p>
            The browser MUST NOT send anything other than a connectivity check unless the port pair is valid.  This ensures that the remote peer has consented to receive packets and that the consent is recent.
          </p>
          <p>
            The status of a port pair can be queried by using <code><var>candidate</var>.<a>status</a>(<var>remotePort</var>)</code>.  This method returns <code>true</code> if a connectivity check between the two ports succeeded recently.
          </p>
        </section>

        <section id="serving">
          <h4>Responding to Connectivity Checks</h4>
          <p>
            The browser responds to valid connectivity checks on all open ports.  Received packets that do not conform with the following rules MUST be ignored:
            <ul>
              <li>
                The packet is a STUN Binding request that contains the STUN magic cookie [[!RFC5389]].
              </li>
              <li>
                The Binding request contains a <code>USERNAME</code> attribute that starts with the browser-assigned username fragment, plus a colon (ASCII 0x3a).
              </li>
              <li>
                The Binding request contains a valid <code>MESSAGE-INTEGRITY</code> attribute that is calculated over the <code>USERNAME</code> attribute.
              </li>
              <li>
                The Binding request contains a valid <code>FINGERPRINT</code> attribute.
              </li>
            </ul>
          </p>
          <p>
            Applications can register a callback listener against a realtime port.  This function is called when a valid connectivity check is received.  The callback signature is identical to the callback for locally originated conectivity checks.  Both the request and response message are passed to the callback.
          </p>
          <p>
            Browsers respond to connectivity checks on each port that it opens.  The browser MUST limit the number of unique peers that it generates connectivity check responses for.  This ensures that the number of flows that can be created towards the browser from different browsers is limited.  This mitigates an attack where a web attacker shares open port information with multiple browsers.
          </p>
        </section>

        <section>
          <h4>The <code>StunBinding</code> Object</h4>
          <p>
            The <code><dfn>StunBinding</dfn></code> object contains information necessary to construct and interpret STUN Binding requests.
          </p>
          <dl title="interface StunBinding" class="idl">
            <dt>readonly attribute ArrayBuffer transactionId</dt>
            <dd>
              The STUN transaction ID is selected by the browser.  This object is only provided to users once a STUN transaction has successfully completed, ensuring that STUN responses cannot be spoofed by web attackers.
            </dd>
            <dt>readonly attribute sequence&lt;StunAttribute> attributes</dt>
            <dd>
              The complete set of STUN attributes in the request in the order that they appear.  Note that attributes that appear after the <code>MESSAGE-INTEGRITY</code> are not authenticated.
            </dd>
            <dt>StunAttribute getStunAttribute(byte type)</dt>
            <dd>
              Retrieves the first appearing <code><a>StunAttribute</a></code> of the given type.  This method only returns authenticated attributes.
            </dd>
            <dt>Address getMappedAddress()</dt>
            <dd>
              A convenience method for accessing the <code>XOR-MAPPED-ADDRESS</code> attribute.  This returns a dictionary containing <code>ip</code> and <code>port</code>.
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>StunAttribute</code> Object</h4>
          <p>
            The <code><dfn>StunAttribute</dfn></code> dictionary contains a single STUN attribute.
          </p>
          <dl title="dictionary StunAttribute" class="idl">
            <dt>byte value</dt>
            <dd>
              The type of the STUN attribute, see <a href="http://www.iana.org/assignments/stun-parameters/stun-parameters.xml#stun-parameters-3">the IANA STUN Attributes registry</a> for a listing of standard values.
            </dd>
            <dt>ArrayBuffer value</dt>
            <dd>
              The binary value of the STUN attribute, from 0 to 255 bytes in length.
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>Address</code> Object</h4>
          <p>
            When referring to addressing information, the following dictionary is used.
          </p>
          <dl title="dictionary Address" class="idl">
            <dt>DOMString ip</dt>
            <dd>
              The IP address, in string form.
            </dd>
            <dt>[EnforceRange] unsigned short port</dt>
            <dd>
              The port number.
            </dd>
          </dl>
        </section>
      </section>

      <section id="networkchange">
        <h3>Network Interface Changes</h3>
        <p>
          Network interfaces are imperfect and impermanent.  They can change, appear and disappear with no warning, especially on mobile devices.  Reacting to changes in connectivity is a crucial part of providing good realtime transport.
        </p>
        <p>
          The <code><dfn>networkchange</dfn></code> event is registered against a local <code><a>RealtimePort</a></code>.
        </p>
        <p class="note">
          Ideally, this would be globally registered, but since <code><a>RealtimePort</a></code> doesn't have a constructor, this might not be necessary.  Again, ideally this is something for the <a href="http://www.w3.org/TR/netinfo-api/">network information API</a> to solve.
        </p>
        <p>
          The browser fires a <code><a>networkchange</a></code> event when it detects a potential change in the status of the network.  Events that trigger this callback include changes to open network interfaces and the addition or removal of network interfaces.
        </p>
      </section>

      <section>
        <h3>Privacy Considerations</h3>
        <p>
          Applications that establish peer-to-peer transports require that the IP addresses of a peer are signaled to the remote peer.  This can pose a privacy exposure even though an IP address can only be loosely correlated with a person.  For instance, it is possible to use IP addresses to determine the physical location of a person.
        </p>
        <p>
          In some applications, establishing a peer-to-peer transport occurs prior to establishing user consent for the session.  This can be necessary to remove the delays associated with transport setup that might otherwise occur after session acceptance.  Exposing IP address information prior to acceptance provides the initiator of the session a way to collect the IP address of even an unwilling peer.
        </p>
        <p>
          Applications are encouraged to only signal relay ports prior to gaining explicit consent from users.
        </p>
      </section>
    </section>

    <section>
      <h2>Realtime Transport</h2>
      
      <p>
        A <dfn>RealtimeTransport</dfn> represents the flow of packets between a local and a remote realtime port.
      </p>
      <p>
        Upon creation, a <code><a>RealtimeTransport</a></code> beings automatically generating connectivity checks toward the selected remote peer.  If a consent check fails, the transport remains open, but no packets can be sent.
      </p>
      <section>
        <h3>The <code>RealtimeTransport</code> Object</h3>
        <dl title="interface RealtimeTransport : EventTarget" class="idl">
          <dt>void createTransport (RealtimePort local, RemoteRealtimePort remote, TransportOptions options, TransportCallback callback)</dt>
          <dd>
            Factory method for creating a transport.
          </dd>
          
          <dt>readonly attribute RealtimePort localPort</dt>
          <dd>
            The local realtime port that is used for this transport.
          </dd>
          <dt>readonly attribute SimpleRealtimePort remotePort</dt>
          <dd>
            The remote realtime port that is used for this transport.
          </dd>
          <dt>readonly attribute boolean dtls</dt>
          <dd>
            Whether key negotiation for the transport is being controlled using DTLS.
          </dd>
          <dt>readonly attribute RemoteCertificateInformation? remoteCertificate</dt>
          <dd>
            Information about the certificate offered by the remote peer.  This attribute is only set if the transport is using DTLS for key negotiation.
          </dd>

          <dt>readonly attribute SrtpSecurityDescription? outboundSdes</dt>
          <dd>
            The SRTP security description for outbound media.
          </dd>
          <dt>readonly attribute SrtpSecurityDescription? inboundSdes</dt>
          <dd>
            The SRTP security description for inbound media.
          </dd>

          <dt>readonly attribute boolean open</dt>
          <dd>
            Whether the transport is currently open and able to receive data.  Newly created transports always start with this value set to <code>true</code>.  Note that absence or expiry of consent from the remote peer can cause a transport to be unable to send on an open transport.
          </dd>
          <dt>readonly attribute unsigned long bandwidth</dt>
          <dd>
            The maximum available bandwidth on this transport, as detected by the browser.  This value can change over time.  Users of the transport operate within this envelope; packets that exceed this limit within any interval (browser-selected) are discarded.
          </dd>
          <dt>void close()</dt>
          <dd>
            This closes the transport.
          </dd>
          <dt>attribute EventHandler? onclose</dt>
          <dd>
            This event callback is fired when the transport is closed.
          </dd>
          <dt>readonly attribute boolean consent</dt>
          <dd>
            Whether the transport is currently open and able to send data.  This depends on there being a successful consent check toward the remote peer within a browser-configured period.  This valid is <code>false</code> when consent toward the remote peer has expired.
          </dd>
          <dt>attribute EventHandler? onconsent</dt>
          <dd>
            This event callback is fired when consent checks toward the remote peer succeed after having failed.
          </dd>
          <dt>attribute EventHandler? onconsentexpired</dt>
          <dd>
            This event callback is fired when consent checks toward the remote peer time out and no packets are able to be sent on this transport.
          </dd>
          <dt>attribute EventHandler? onbandwidthchange</dt>
          <dd>
            This event callback is fired when the browser learns of a change in available bandwidth on the transport.  The browser MAY limit the rate of notifications, or suppress notification for small (10% or less) changes in available bandwidth.
          </dd>
        </dl>
      </section>

      <section>
        <h3>Transport Creation Options</h3>
        <p>
          Specifying <code><dfn>RealtimeTransportOptions</dfn></code> can be used to alter the characteristics of a transport.
        </p>
        <dl title="dictionary RealtimeTransportOptions">
          <dt>RealtimeTransportMode mode = "dtls-srtp"</dt>
          <dd>
            The mode used for the transport.
          </dd>
          <dt>SrtpSecurityDescription? outboundSdes</dt>
          <dd>
            A description of the security parameters for outbound streams of RTP media secured with SRTP [[!RFC3711]].  Used only when SRTP keys are negotiated through signaling.
          </dd>
          <dt>SrtpSecurityDescription? inboundSdes</dt>
          <dd>
            A description of the security parameters for inbound streams of RTP media secured with SRTP [[!RFC3711]].  Used only when SRTP keys are negotiated through signaling.
          </dd>
          <dt>DtlsRole? role</dt>
          <dd>
            The role that the local browser takes in the DTLS [[!RFC5764]] handshake, either 'client' or 'server'.
          </dd>
          <dt>CertificateValidationCallback? validate</dt>
          <dd>
            This callback is triggered when the certificate for the remote peer is received.  This allows the application to accept or reject a peer based on the proffered certificate.  This is only valid for a DTLS transport.  When omitted, the certificates is automatically accepted.
          </dd>
        </dl>
        <section>
          <h4>Realtime Transport Modes</h4>
          <p>
            </p>
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-RealtimeTransportMode">RealtimeTransportMode</a></span> {
    "<a href="#widl-RealtimeTransportMode-srtp">srtp</a>", "<a href="#widl-RealtimeTransportMode-dtls-srtp">dtls-srtp</a>"
};
          </pre>
          <!-- <dl title="enum DtlsRole" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-RealtimeTransportMode-srtp"><code>srtp</code></dt>
            <dd>
              Instructs the browser to create a <code><a>RealtimeTransport</a></code> using SRTP.  When this option is chosen, the <code><a>RealtimeTransportOptions</a></code> MUST also include <code><a href="#widl-RealtimeTransportOptions-outboundSdes">outboundSdes</a></code> and <code><a href="#widl-RealtimeTransportOptions-inboundSdes">inboundSdes</a></code>.
            </dd>
            <dt id="widl-RealtimeTransportMode-dtls-srtp"><code>dtls-srtp</code></dt>
            <dd>
              Instructs the browser to create a <code><a>RealtimeTransport</a></code> using DTLS-SRTP [[!RFC5764]].  When this option is chosen, the <code><a>RealtimeTransportOptions</a></code> MUST also include <code><a href="#widl-RealtimeTransportOptions-role">role</a></code> and it SHOULD include <code><a href="#widl-RealtimeTransportOptions-validate">validate</a></code>.
            </dd>
          </dl>
        </section>
        <section>
          <h4>DTLS Roles</h4>
          <p>
            DTLS Roles are applicable when creating a transport over DTLS.  This option determines whether the local browser is in the client or server role.
          </p>
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-DtlsRole">DtlsRole</a></span> {
    "<a href="#widl-DtlsRole-client">client</a>", "<a href="#widl-DtlsRole-server">server</a>"
};
          </pre>
          <!-- <dl title="enum DtlsRole" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-DtlsRole-client"><code>client</code></dt>
            <dd>
              Instructs the browser to act as a DTLS server when creating a <code><a>RealtimeTransport</a></code>.  The browser acts as a DTLS client and initiates the DTLS handshake.
            </dd>

            <dt id="widl-DtlsRole-server"><code>server</code></dt>
            <dd>
              Instructs the browser to act as a DTLS server when creating a <code><a>RealtimeTransport</a></code>.  The browser waits for the remote peer to initiate the DTLS handshake.
            </dd>
          </dl>
        </section>
        <section>
          <h4>Certificate Validation Callback</h4>
          <p>
            This callback method is invoked when a DTLS transport is being created.  It allows the application to block the creation of a new transport based on the identity of the peer.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-CertificateValidationCallback" class="idlCallback">callback <span class="idlDictionaryID">CertificateValidationCallback</span> = boolean (<span class="idlParamType">RemoteCertificateInformation</span> <span class="idlParamName">remoteCertificate</span>);</span>
          </pre>
          <p>
            The callback is passed information about the certificate offered by the remote peer.  The application can make a decision based on this and either return <code>true</code> to indicate that the transport creation should proceed, or <code>false</code> to indicate that the transport creation should be aborted.
          </p>
        </section>
        <section>
          <h4>Certificate Information</h4>
          <p>
            Information about an X.509 certificate, as used with DTLS.
          </p>
          <p>
            This is another candidate for moving to another working group.
          </p>
          <p class="note">
            Users are expected to make their own determination about trustworthiness based on the feedback information presented in browser chrome.  Certificate information allows application developers a better way of building more trustworthy applications.
          </p>
          <dl title="[NoInterfaceObject] interface CertificateInformation" class="idl">
            <dt>static CertificateInformation getLocalCertificate()</dt>
            <dd>
              This method retrieves the certificate that the browser will use for creating realtime transport.  The application can use this information to signal to peers.
            </dd>
            
            <dt>readonly attribute ArrayBuffer certificate</dt>
            <dd>
              The DER-encoded certificate information.
            </dd>
            <dt>readonly attribute DOMString subject</dt>
            <dd>
              The subject of the certificate, using the string encoding from RFC 4514.
            </dd>
            <dt>readonly attribute CertificateFingerprints fingerprint</dt>
            <dd>
              A dictionary containing fingerprints for the certificate.  Keys are the <a href="http://www.iana.org/assignments/hash-function-text-names/hash-function-text-names.xml">textual name for the hash function</a>; the corresponding value for each is an <code>ArrayBuffer</code> containing the value of the fingerprint.  Browsers MUST implement SHA-1 (<code>sha-1</code>) and SHA-2 256 (<code>sha-256</code>).
            </dd>
          </dl>
        </section>
        <section>
          <h4>Remote Certificate Information</h4>
          <p>
            Information about a remotely proffered X.509 certificate, which includes all the basic certificate information, plus fields that reveal what knowledge the browser has about trust (for instance, is this a valid domain certificate).
          </p>
          <p>For example, an application might register the following <code>CertificateValidationCallback</code> to check that it is talking to the expected domain:
          </p>
          <pre class="example">
function validateCertificate(certInfo) {
    return certInfo.isValidForDomain('example.com');
}
          </pre>

          <dl title="[NoInterfaceObject] interface RemoteCertificateInformation : CertificateInformation" class="idl">
            <dt>boolean isValidForDomain(DOMString domainName)</dt>
            <dd>
              This method returns true iff the certificate chains to one of the trust anchors configured in the browser for the specified domain name.  This allows an application to validate that a peer is offering a valid certificate for its domain.
            </dd>
          </dl>
        </section>
        <section>
          <h4>SRTP Security Descriptions</h4>
          <p>
            This dictionary describes the parameters necessary to interoperably configure an SRTP stream.  Default values are the defaults defined in [[!RFC3711]].
          </p>
          <dl title="dictionary SrtpSecurityDescription" class="idl">
            <dt>DOMString encrypt = "AES-CM"</dt>
            <dd>
              The SRTP cipher to use for encrypting packets.
            </dd>
            <dt>boolean encryptRtp = true</dt>
            <dd>
              Whether to encrypt RTP packets on this flow.
            </dd>
            <dt>boolean encryptRtcp = true</dt>
            <dd>
              Whether to encrypt RTCP packets on this flow.
            </dd>
            <dt>unsigned short keystreamPrefix = 0</dt>
            <dd>
              The number of bits to reserve from the keystream for use in authenticating each encoded packet.
            </dd>
            <dt>DOMString authenticate = "HMAC-SHA1"</dt>
            <dd>
              The packet authentication algorithm used.
            </dd>
            <dt>unsigned short n_a = 160</dt>
            <dd>
              The number of bits in the authentication output.
            </dd>
            <dt>unsigned short n_tag = 80</dt>
            <dd>
              The number of bits from the authentication output to append to the packet.
            </dd>
            <dt>DOMString keyDerivation = "AES-CM"</dt>
            <dd>
              The algorithm to use for key derivation.
              </dd>
            <dt>unsigned long keyDerivationInterval = 0</dt>
            <dd>
              The packet index at which new keys are derived.  A value of 0 indicates that new keys are never derived.
            </dd>
            <dt>ArrayBuffer key</dt>
            <dd>
              The master key.  The size of this ArrayBuffer determines <code>n_a</code>.
            </dd>
            <dt>ArrayBuffer salt</dt>
            <dd>
              The master salt.  The size of this ArrayBuffer determines <code>n_s</code>.
            </dd>
            <dt>unsigned long? windowSizeHint</dt>
            <dd>
              A hint to a receiver that indicates how large a replay protection window it is requested to maintain.  This value MAY be ignored.
            </dd>
            <dt>unsigned long long rtpPacketCount = 281474976710656</dt>
            <dd>
              The number of packets that can be safely encrypted using this scheme for RTP.  Default value of 2<sup>48</sup>.
            </dd>
            <dt>unsigned long long rtcpPacketCount = 2147483648</dt>
            <dd>
              The number of packets that can be safely encrypted using this scheme for RTCP.  Default value of 2<sup>31</sup>.
            </dd>
            <dt>ArrayBuffer? mki</dt>
            <dd>
              The optional master key index.  The size of the ArrayBuffer determines the size.
            </dd>
          </dl>
        </section>
      </section>
    </section>
    
    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        Thanks to Matthew Kaufman who provided a few key suggestions that resulted in an almost total removal of browser-based state.  Travis Leithead provided guidance on modern web API design that was invaluable.
      </p>
    </section>
  </body>
</html>
