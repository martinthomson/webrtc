<!DOCTYPE html>
<html>
  <head>
    <title>Customizable, Ubiquitous Real-Time Communication over the Web</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <script src="http://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class="remove">
      var respecConfig = {
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "unofficial",
      
      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "realtime-media",

      // if your specification has a subtitle that goes below the main
      // formal title, define it here
      subtitle   :  "Real-Time Media and Peer-to-Peer Transport API",

      // if you wish the publication date to be other than today, set this
      // publishDate:  "2009-08-06",

      // if the specification's copyright date is a range of years, specify
      // the start date here:
      copyrightStart: "2012",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "https://github.com/martinthomson/webrtc/blob/master/realtime-media-stream.html",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css", "http://www.w3.org/StyleSheets/TR/W3C-Member-SUBM"],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
      { name: "Martin Thomson", url: "mailto:martin.thomson@gmail.com",
        company: "Microsoft", companyURL: "http://microsoft.com/" }
      ],

      // authors, add as many as you like. 
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      authors:  [
      { name: "Bernard Aboba", url: "mailto:bernard_aboba@hotmail.com",
        company: "Microsoft", companyURL: "http://microsoft.com/" },
      { name: "Matthew Kaufman", url: "mailto:matthew.kaufman@skype.net",
        company: "Microsoft", companyURL: "http://microsoft.com/" }
      ],
      
      // name of the WG
      wg:           "WebRTC Working Group",
      
      // URI of the public WG page
      wgURI:        "http://www.w3.org/standards/techs/webrtc",
      
      // name (without the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-webrtc",
      
      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/47318/status",
      maxTocLevel: 2
      };
    </script>
    <style type="text/css">
/* copied from pre.idl */
pre.pseudoidl:before {
    background: none repeat scroll 0 0 #90B8DE;
    color: #FFFFFF;
    content: "WebIDL";
    display: block;
    font-family: initial;
    font-weight: bold;
    margin: -1em 0 1em -1em;
    padding: 3px;
    width: 150px;
}
pre.pseudoidl {
    border-bottom: 1px solid #90B8DE;
    border-top: 1px solid #90B8DE;
    line-height: 120%;
    padding: 1em;
}
#respec-err { display: none }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        An API is described for sourcing and terminating streams of real-time media in a browser.  The API provides a means of describing how media streams are serialized into a stream of RTP packets or deserialized from a stream of packets.
      </p>
      <p>
        The API is structed in two sections: Real-Time Media Streaming and Real-Time, Peer-to-Peer Transport.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        Thanks in no small part to the exponential improvements in Web infrastructure over the last few years, it is now possible to leverage the digital backbone of the Internet to create experiences for which dedicated media and networks (cable TV, telephone) were necessary until not too long ago. Furthermore, these developments have enabled the creation of media experiences heretofore either plainly inaccessible or too impractical for most. 
      </p>
      <p>
        Inexpensive, real time video conferencing is one such experience. It has grown enormously in popularity and it is now a daily component of many peopleâ€™s lives, bringing together families and friends, and making business easier all over the world. 
      </p>
      <p>
        But there are other applications of the same general technology, which are also experiencing substantial growth. Online gaming requires the real time exchange of data across geographically dispersed computers, and so do certain business critical applications like those that govern the functioning of financial markets. 
      </p>
      <p>
        The Internet Engineering Task Force and the World Wide Web Council have recently created complementary working groups to bring these powerful capabilities to the most familiar and widespread application used to experience the Internet: the web browser. The goal of this initiative is to add a new level of interactivity for web users with real-time communications (Web RTC) in the browser. 
      </p>
      <p>
        While the overarching goal is simple to describe, there are several critical requirements that a successful, widely adoptable Web RTC API will need to meet: 
      </p>
      <ul>
        <li>
          <strong>Customizable response to changing network quality</strong>&mdash;Real time media applications have to run on networks with a wide range of capabilities varying in terms of bandwidth, latency, and noise. Likewise these characteristics can change while an application is running. Developers should be able to control how the user experience adapts to fluctuations in communication quality. For example, when communication quality degrades, the developer may prefer to favor the video channel, favor the audio channel, or suspend the app until acceptable quality is restored. An effective protocol and API will have to arm developers with the tools to tailor such answers to the exact needs of the moment, while minimizing the complexity of the resulting API surface. 
        </li>
        <li>
          <strong>Ubiquitous deployability on the existing network infrastructure</strong>&mdash;Interoperability is critical if WebRTC users must be able to communicate with the rest of the world, with users on different browsers, VoIP phones, and mobile phones, from behind firewalls and across routers and equipment that is unlikely to be upgraded to the current state of the art anytime soon. 
        </li>
        <li>
          <strong>Flexibility in its support of popular media formats and codecs as well as openness to future innovation</strong>&mdash;A successful standard cannot be tied to individual codecs, data formats or scenarios. They may soon be supplanted by newer versions, which would make such a tightly coupled standard obsolete just as quickly. The right approach is instead to bring the bulk of the logic to the application layer, enabling dDevelopers to innovate. 
        </li>
        <li>
          <strong>Honoring key Web tenets</strong>&mdash;The Web favors stateless interactions which do not saddle either party of a data exchange with the responsibility to remember what the other did or expects. Doing otherwise is a recipe for extreme brittleness in implementations; it also raises considerably the development cost which reduces the reach of the standard itself. 
        </li>
      </ul>
    </section>
    
    <section id="media">
      <h2>Real-Time Media Streaming</h2>
      <p>
        Real-Time communications between browsers depends on the packetization of media.  This API provides a way to control how media streams are turned into packets and how those packets are turned into media streams.
      </p>
      <p>
        Interoperable real-time media between browsers uses RTP [[!I-D.rtcweb-rtp-usage]].  RTP depends on the existence of a signaling channel to establish a common understanding of the meaning of packets.  This includes identification of different streams, codecs, and codec parameters.
      </p>
      <p>
        An RTP session consists of a series of RTP streams.  Each stream has a source and one or more sinks.  This API provides objects that directly map to RTP streams.  The source and sink of each real-time media stream is a <code>MediaStreamTrack</code> [[!GETUSERMEDIA]].  This allows applications to build more complex arrangements of streams, composing them into aggregate <code>MediaStream</code> collections.
      </p>
      <p>
        Exchanging media in real time between browsers requires the use of a real time media transport, such as is described in <a href="#transport" class="sectionRef"></a>.
      </p>
      <p>
        The exchange of real-time media between two browsers follows the process:
        <ol>
          <li>
            At the media source, input devices are opened for capture.
          </li>
          <li>
            Media from the input devices is encoded into packets that are transmitted across the network.
            </li>
          <li>
            At the media destination, the packets are decoded and formed into a media stream.
          </li>
          <li>
            The media stream is sent to output devices.
          </li>
        </ol>
      </p>
      <p>
        Local capture and playback of media (steps 1. and 4.) can be achieved by the media capture API [[!GETUSERMEDIA]].  The real-time media streaming API provides access to functions that allow for the transmission of media stream across a network between these two points.
      </p>
      <img src="overview.png" alt="Image showing overview of real-time media" title="Overview of Real-Time Media" />
      <p>
        The basic primitive of this API, the <code><a>RealtimeMediaStream</a></code> is a single, unidirectional stream of media.  This basic unit can be used to assemble more complex communications scenarios.  For example, an application that wishes to enable two-way audio and video communications between peers can create four such streams: an audio stream in each direction, plus a video stream in each direction.
      </p>
      <p>
        In order to transmit a track from a local media stream&mdash;audio or video&mdash;an application takes the track and a <code><a>RealtimeTransport</a></code> and creates a <code><a>RealtimeMediaStream</a></code>.  A <code><a>RealtimeMediaDescription</a></code> is used to describe how the track is encoded.
      </p>
      <pre class="example">
navigator.getUserMedia({ audio: true }, function(media) {
    var track = media.audioTracks[0];
    var description = new RealtimeMediaDescription(track);
    var localRtStream = new LocalRealtimeMediaStream(track, description, realtimeTransport);
    signalingChannel.send(description.toDictionary());
});
      </pre>
      <p>
        In order to receive the same stream, the <code><a>RealtimeMediaDescription</a></code> is signaled between the two peers.  This description can be used to create a <code><a>RealtimeMediaStream</a></code> that decodes encoded tracks.
      </p>
      <pre class="example">
function receiveDescriptionFromSignaling(remoteDescription) {
    var description = new RealtimeMediaDescription(remoteDescription);
    var remoteRtStream = new RemoteRealtimeMediaStream(description, realtimeTransport);
    var remoteMedia = new MediaStream(remoteRtStream.track);
    outputTag.src = URL.createObjectURL(remoteMedia);
});
      </pre>
    </section>

    <section>
      <h2>The RealtimeMediaStream Object</h2>
      <p>
        A <code>RealtimeMediaStream</code> represents a uni-directional flow of media to or from the browser.
      </p>
      <p>
        Instances of <code>RealtimeMediaStream</code> are created through type-specific constructors, either <code><a>LocalRealtimeMediaStream</a></code> or <code><a>RemoteRealtimeMediaStream</a></code>.  Each MUST be created for a single type of stream; audio and video cannot be mixed in a single stream.
      </p>
      <p>
        Synchronization of streams is achieved by having audio and video tracks added to the same <code>MediaStream</code> so that packet timestamps and playback can be properly matched between the streams.
      </p>
      <dl title="[NoInterfaceObject] interface RealtimeMediaStream : EventTarget" class="idl">
        <dt>readonly attribute MediaStreamTrack track</dt>
        <dd>
          The media track that is either being consumed or produced by this realtime media stream.
        </dd>
        <dt>readonly attribute RealtimeTransport transport</dt>
        <dd>
          The transport that is being used to transmit and receive RTP packets.
        </dd>
        <dt>readonly attribute RealtimeTransport rtcpTransport</dt>
        <dd>
          The transport that is being used to transmit and receive RTCP packets.
        </dd>
        <dt>readonly attribute RealtimeMediaDescription description</dt>
        <dd>
          The description that is being used for this stream.
        </dd>
        <dt>void updateDescription(RealtimeMediaDescription description)</dt>
        <dd>
          Change the description that is being used for the stream atomically.
        </dd>
        <dt>void updateTransport(RealtimeTransport transport, optional RealtimeTransport rtcpTransport)</dt>
        <dd>
          Change the underlying transport that is being used for the stream.  Optionally, set a different transport for the RTCP feedback for the stream.  If the <code>rtcpTransport</code> parameter is omitted or the same as the <code>transport</code>, then RTCP multiplexing with RTP [[!RFC5761]] is used.
        </dd>
        <dt>void play()</dt>
        <dd>
          Causes the encoding of the stream and the corresponding creation of packets to be resumed.
        </dd>
        <dt>void pause()</dt>
        <dd>
          Causes the encoding of the stream and the corresponding creation of packets to be temporarily suspended.
        </dd>
        <dt>void stop()</dt>
        <dd>
          Halts the encoding of the stream and closes the stream.  The stream cannot be used after this.
        </dd>
        <dt>readonly attribute boolean playing</dt>
        <dd>
          <p>This value is <code>true</code> if the stream is playing.  A playing stream generates packets on the transport if the transport is open.</p>
          <p class="note">This value can be true if the underlying <code>RealtimeTransport</code> is currently closed.</p>
        </dd>
      </dl>

      <section>
        <h3>The <code>LocalRealtimeMediaStream</code> Object</h3>
        <p>
          The <code>LocalRealtimeMediaStream</code> represents a locally-sourced stream of real-time media.
        </p>
        <p>
          The constructor for <code>LocalRealtimeMediaStream</code> ignores any information in the <code>RealtimeMediaDescription</code> that it is passed that is not applicable to the provided track.
        </p>
        <dl title="[Constructor(MediaStreamTrack track, RealtimeMediaDescription description, RealtimeTransport transport, optional RealtimeTransport rtcpTransport)] interface LocalRealtimeMediaStream : RealtimeMediaStream" class="idl">
        </dl>
      </section>

      <section>
        <h3>The <code>RemoteRealtimeMediaStream</code> Object</h3>
        <p>
          A <code>RemoteRealtimeMediaStream</code> represents a stream of real-time media that originates on the network.
        </p>
        <p>
          The constructor to <code>RemoteRealtimeMediaStream</code> constructs a <code>MediaStreamTrack</code> based on the provided <code>RealtimeMediaDescription</code>.  If the browser is unable to construct this object, then an error is thrown.  This error might be thrown if the media description includes information for both audio and video tracks.
        </p>
        <dl title="[Constructor(RealtimeMediaDescription description, RealtimeTransport transport, optional RealtimeTransport rtcpTransport)] interface RemoteRealtimeMediaStream : RealtimeMediaStream" class="idl">
          <dt>attribute UnknownPacketTypeEventHandler? onunknownpackettype</dt>
          <dd>
            Called when an <a href="#unknownpackettype">unknown packet type</a> arrives on the stream.
          </dd>
        </dl>

        <section id="unknownpackettype">
          <h4>Dealing with Mismatched Media Descriptions</h4>
          <p>
            Some errors in media descriptions cannot be immediately detected by the browser.  Descriptions that contain unsupported or conflicting features can be readily detected.  Other errors are not obvious until incompatible media arrives.
          </p>
          <p>
            One such error arises for an incoming stream when an RTP packet type is not assigned to a codec. In this case, the first instance of an RTP packet arriving with an unknown packet type triggers an <code>UnknownPacketTypeEvent</code> to be fired.  After the first instance of this event, packets marked with the unknown packet type are ignored.
          </p>
          <p>
            Updating the <code><a>RealtimeMediaDescription</a></code> on a stream resets the event status of any existing unknown packet types.  When another packet containing an unknown packet type arrives, the event is fired once more.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>The <code>RealtimeMediaDescription</code> Object</h2>
      <p>
        A <code><dfn>RealtimeMediaDescription</dfn></code> is the basic means of specifying what a packetized stream of media looks like.  A <code>RealtimeMediaDescription</code> is used to specify what an outgoing stream is to look like and to describe what an incoming stream looks like.
      </p>
      <p>
        <code>RealtimeMediaDescription</code> provides a basic form of media negotiation through the <code href="#widl-RealtimeMediaDescription-update-RealtimeMediaDescription-RealtimeMediaDescriptionDictionary-constraints">update()</code> method.
      </p>
      <dl title="[Constructor (optional (MediaStreamTrack or RealtimeMediaDescriptionDictionary or RealtimeMediaDescriptionConstraints) constraints)] interface RealtimeMediaDescription" class="idl">
        <dt>readonly attribute sequence&lt;RtpStreamDescription> streams</dt>
        <dd>
          A description of the RTP streams that comprise the real-time stream.  Most codecs only support a single RTP stream.  Only layered codecs such as H.264 SVC [[!RFC6190]] are encoded into multiple streams.  Streams are ordered with dependent streams coming after the streams they depend on.
        </dd>
        <dt>readonly attribute DOMString cname</dt>
        <dd>
          The RTCP Canonical Name (CNAME) used to identify this browser as a source of media in RTCP.  As described in [[I-D.rtcweb-rtp-usage]], the browser generates a short-term CNAME that cannot be linked to its identity over time.
        </dd>
        <dt>readonly attribute sequence&lt;RtpExtension>? rtpExtensions</dt>
        <dd>
          The set of RTP extensions [[!RFC5285]] that are used by the described stream(s).  Omission of the attribute (a null value) indicates that extensions are not supported, an empty set indicates that extensions are supported but ignored.
        </dd>
        <dt>readonly attribute sequence&lt;RtcpFeature> rtcpFeatures</dt>
        <dd>
          The set of RTCP features that are used by the described stream(s).
        </dd>
        <dt>readonly attribute sequence&lt;CodecDescription> codecs</dt>
        <dd>
          A description of the set of codecs that are used by the described stream(s).
        </dd>
        <dt>readonly attribute byte? priority</dt>
        <dd>
          The relative priority of the stream.  1 is highest, 3 is the lowest and the default.  This determines how the browser prioritizes this stream against other streams when there is limited available bandwidth as well as how the stream is marked on the network.
        </dd>
        <dt>RealtimeMediaDescription update (RealtimeMediaDescriptionDictionary constraints)</dt>
        <dd>
          Update the description to include only those settings that are specified in the provided dictionary.  This can be used as a basis for negotiating a common set of capabilities between peers.  This throws an <code>Error</code> if the resulting description cannot possibly be used to describe any real-time stream because the constraints are incompatible with the current state of the description.
        </dd>
        <dt>RealtimeMediaDescription update (RealtimeMediaDescriptionConstraints constraints)</dt>
        <dd>
          Update the description to conform to the provided constraints.  This throws an <code>Error</code> if the mandatory constraints cannot be met.
        </dd>
        <dt>RealtimeMediaDescriptionDictionary toDictionary ()</dt>
        <dd>
          Extracts the data from this description as a <code><a>RealtimeMediaDescriptionDictionary</a></code>.  This method allows for easier application access to data for exchange with peers.
        </dd>
      </dl>

      <section>
        <h3>The <code>RealtimeMediaDescriptionDictionary</code> Object</h3>
        <p>
          Since a media description is likely to be exchanged over a signaling channel, this object represents the value of a <code><a>RealtimeMediaDescription</a></code> without the corresponding methods.
        </p>
        <dl title="dictionary RealtimeMediaDescriptionDictionary" class="idl">
          <dt>sequence&lt;RtpStreamDescription> streams</dt>
          <dd>
            A description of the RTP streams that comprise the real-time stream.
          </dd>
          <dt>DOMString cname</dt>
          <dd>
            The RTCP Canonical Name (CNAME) used to identify this browser as a source of media in RTCP.
          </dd>
          <dt>sequence&lt;RtpExtension>? rtpExceptions = null</dt>
          <dd>
            The set of RTP extensions that are used by the described stream(s).  Omission of the attribute indicates that extensions are not supported, an empty set indicates that extensions are supported but ignored.
          </dd>
          <dt>sequence&lt;RtcpFeature> rtcpFeatures</dt>
          <dd>
            The set of RTCP features that are used by the described stream(s).
          </dd>
          <dt>sequence&lt;CodecDescription> codecs</dt>
          <dd>
            A description of the set of codecs that are used by the described stream(s).
          </dd>
          <dt>byte priority = 3</dt>
          <dd>
            The relative priority of the stream.
          </dd>
        </dl>
      </section>

      <section>
        <h3>The <code>RtpStreamDescription</code> Object</h3>
        <p>
          A <code>RtpStreamDescription</code> describes a single codec and how it is applied to both encoding or decoding.  This includes the packet type for the codec and any codec-specific parameters.
        </p>
        <dl title="dictionary RtpStreamDescription" class="idl">
          <dt>unsigned int ssrc</dt>
          <dd>
            Each RTP stream has a unique, 32-bit synchronization source (SSRC).  This value is used to identify a single stream in an RTP session.  The browser allocates a new, random SSRC from the set of available SSRC values for each stream, though this value can be overridden by the application.  The browser MAY alter this value if it detects an SSRC collision within the RTP session.
          </dd>
          <dt>unsigned long bandwidth?</dt>
          <dd>
            The maximum bandwidth, in bits per second, allowed for this stream.  This instructs the browser to constrain the stream to fit within this limit.  The browser is able to choose the method it uses to meet this constraint.
          </dd>
        </dl>
      </section>

      <section>
        <h3>The <code>RtpExtension</code> Object</h3>
        <p>
          RTP Extensions [[!RFC5285]] enables the addition of extension information to the RTP header.  This enumeration identifies specific extensions that might be enabled.  A set of these values may be used to describe each real-time stream.  Omitting the set indicates that header extensions cannot be used on the stream.
        </p>
        <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-RtpExtension">RtpExtension</a></span> {
    "<a href="#widl-RtpExtension-rapid-sync">rapid-sync</a>", "<a href="#widl-RtpExtension-c2m-alevel">c2m-alevel</a>", "<a href="#widl-RtpExtension-m2c-alevel">m2c-alevel</a>"
};
        </pre>
        <!-- <dl title="[NoInterfaceObject] enum TurnRelayTransport" class="enum" data-transform="transformEnum">-->
        <dl class="attributes">
          <dt id="widl-RtpExtension-rapid-sync"><code>rapid-sync</code></dt>
          <dd>
            The RTP extension that enables rapid synchronization [[!RFC6051]].
          </dd>
          <dt id="widl-RtpExtension-c2m-alevel"><code>c2m-alevel</code></dt>
          <dd>
            The client-to-mixer audio level extension [[!RFC6464]] with mandatory header encryption.
          </dd>
          <dt id="widl-RtpExtension-m2c-alevel"><code>m2c-alevel</code></dt>
          <dd>
            The mixer-to-client audio level extension [[!RFC6465]] with mandatory header encryption.
          </dd>
        </dl>
       </section>

     <section>
        <h3>The <code>RtcpFeature</code> Object</h3>
        <p>
          The real-time feedback channel provided by RTCP [[!RFC3550]] supports a number of optional features.  This enumeration identifies specific features.  A set of these values are used to describe each real-time stream.
        </p>
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-RtcpFeature">RtcpFeature</a></span> {
    "<a href="#widl-RtcpFeature-avpf">avpf</a>", "<a href="#widl-RtcpFeature-nack">nack</a>", "<a href="#widl-RtcpFeature-pli">pli</a>", "<a href="#widl-RtcpFeature-sli">sli</a>", "<a href="#widl-RtcpFeature-rpsi">rpsi</a>", "<a href="#widl-RtcpFeature-reduced">reduced</a>", "<a href="#widl-RtcpFeature-rtx">rtx</a>", "<a href="#widl-RtcpFeature-fir">fir</a>", "<a href="#widl-RtcpFeature-tmmbr">tmmbr</a>", "<a href="#widl-RtcpFeature-tstr">tstr</a>"
};
          </pre>
          <!-- <dl title="[NoInterfaceObject] enum TurnRelayTransport" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-RtcpFeature-avpf"><code>avpf</code></dt>
            <dd>
              The extended profile for RTCP-based feedback, AVPF [[!RFC4585]].
            </dd>
            <dt id="widl-RtcpFeature-nack"><code>nack</code></dt>
            <dd>
              The RTCP generic NACK [[!RFC4585]] feedback feature.
            </dd>
            <dt id="widl-RtcpFeature-pli"><code>pli</code></dt>
            <dd>
              RTCP picture loss indication (PLI) message [[!RFC4585]].
            </dd>
            <dt id="widl-RtcpFeature-sli"><code>sli</code></dt>
            <dd>
              RTCP slice loss indication (SLI) message [[!RFC4585]].
            </dd>
            <dt id="widl-RtcpFeature-rpsi"><code>rpsi</code></dt>
            <dd>
              RTCP reference picture selection indication (RPSI) message [[!RFC4585]].
            </dd>

            <dt id="widl-RtcpFeature-reduced"><code>reduced</code></dt>
            <dd>
              Reduced sized RTCP [[!RFC5506]].
            </dd>
            <dt id="widl-RtcpFeature-rtx"><code>rtx</code></dt>
            <dd>
              RTP retransmission [[!RFC4588]].
            </dd>

            <dt id="widl-RtcpFeature-fir"><code>fir</code></dt>
            <dd>
              RTCP full intra-frame request (FIR) message [[!RFC5104]].
            </dd>
            <dt id="widl-RtcpFeature-tmmbr"><code>tmmbr</code></dt>
            <dd>
              Temporary maximum media stream bit rate request (TMMBR) [[!RFC5104]].
            </dd>
            <dt id="widl-RtcpFeature-tstr"><code>tstr</code></dt>
            <dd>
              Temporal-spatial trade-off (TSTR) [[!RFC5104]].
            </dd>
          </dl>
      </section>

      <section>
        <h3>The <code>CodecDescription</code> Object</h3>
        <p>
          A <code>CodecDescription</code> describes a single codec and how it is applied to both encoding or decoding.  This includes the packet type for the codec and any codec-specific parameters.
        </p>
        <p>
          When generating a <code>RealtimeMediaDescription</code>, the browser MUST specify values for all fields.  Values can be omitted from <code>RealtimeMediaDescriptionDictionary</code> values, which allows the browser to select values for any unspecified values.
        </p>
        <dl title="dictionary CodecDescription" class="idl">
          <dt>DOMString type</dt>
          <dd>
            The MIME media type for the codec.  For example, <code>video/H264</code> or <code>audio/PCMA</code>.
          </dd>
          <dt>byte packetType</dt>
          <dd>
            The packet type that is used for this particular codec.
          </dd>
          <dt>unsigned long clockRate</dt>
          <dd>
            The clock rate for this codec description, specified in Hertz.
          </dd>
          <dt>unsigned short? ptime</dt>
          <dd>
            The packet time for this particular codec.  Used to specify the packet time where a choice exists.
          </dd>
          <dt>unsigned short? maxPtime</dt>
          <dd>
            The maximum packet time for this particular codec.  Used for codecs with a variable packet time.
          </dd>
          <dt>boolean silenceSuppression = true</dt>
          <dd>
            For audio codecs that support silence suppression, this value determines if the codec is permitted to perform silence suppression.
          </dd>
          <dt>DOMString fmtp = ""</dt>
          <dd>
            Format-specific parameters for the codec, taken from the SDP definition for the codec.
          </dd>
        </dl>
      </section>

      <section>
        <h3>The <code>RealtimeMediaDescriptionConstraints</code> Object</h3>
        <p>
          The constraints structure is defined in [[!GETUSERMEDIA]].  <code><dfn>RealtimeMediaDescriptionConstraints</dfn></code> uses this scheme with a different set of possible constraints.
        </p>
        <p>
          The following constraints are defined:
        </p>
        
        <dl>
          <dt>rtcp</dt>
          <dd>
            A set of RTCP features (in an array) that contains all the features that are permitted and desired.  This constraint can be met if the RTCP features on all streams are exactly the provided set.
          </dd>
          <dt>silenceSuppression</dt>
          <dd>
            A <code>boolean</code> value that determines the value for the <code>silenceSuppression</code> parameter of the <code><a>CodecDescription</a></code>.
          </dd>
          <dt>bandwidth</dt>
          <dd>
            An <code>unsigned long</code> value for the overall bandwidth allocated to the stream (or set of streams).
          </dd>
        </dl>
      </section>
    </section>
    

    <section id="transport">
      <h2>Real-Time Transport Layer</h2>
      <p>
        Establishing flows of real-time media to and from browsers requires a transport that is suited to this purpose.  This document describes how real-time transport flows can be created in a browser. A real-time transport flow is a construct that allows for bidirectional exchange of UDP packets.
      </p>
      <p>
        UDP and RTP [[!RFC3550]] provide the means for the delivery of time-sensitive media between peers.  This channel is secured using SRTP [[!RFC3711]] with key negotiation in signaling or through DTLS.
      </p>
      <p>Establishing flows of UDP through middleboxes such as Network Address Translators (NAT) or firewalls requires the use of techniques such as Interactive Connectivity Establishment (ICE) [[!RFC5245]].  The provided API describes primitives that enable the implementation of ICE, but do not require it other than requiring the consent mechanisms that it provides, which is critical to the security of the web.
      </p>
      <p>
        This API only deals with the creation of a secured transport between peers.
      </p>

      <section>
        <h3>Real-Time Transport with <code>RealtimeTransportBuilder</code></h3>
        <p>
          The <code><a>RealtimeTransportBuilder</a></code> provides a simple interface for the creation of peer-to-peer real-time transport.
        </p>
        <p>
          Operation of the <code><a>RealtimeTransportBuilder</a></code> is straightforward.  The constructor accepts the options that include the <code><a>RealtimeTransportOptions</a></code> used to construct a <code><a>RealtimeTransport</a></code>.  After calling <code>start()</code>, the transport builder produces events when ICE candidates (<code>RealtimePort</code>s) are gathered, and when a transport is successfully created.  The following example illustrates its use.
        </p>
        <pre class="example">
var options = { transport: transportOptions, stun: stunServer };
var builder = new RealtimeTransportBuilder(options);
builder.onport = function(e) {
    signaling.send('port', e.port);
};
signaling.onport = function(port) {
    builder.addRemote(port);
};
builder.onconnect = function(e) {
    e.target.stop();
    gotTransport(e.transport);  // at which point streams can be added, etc...
};
builder.start();
        </pre>
      </section>
      
      <section>
        <h3>Real-Time Transport without <code>RealtimeTransportBuilder</code></h3>
        <p>
          Advanced uses of the transport API can establishing real-time media transport by interacting with the following two objects:
          <ul>
            <li>
              The <code><a>RealtimePort</a></code> is the end point for a real-time transport.  This represents a UDP port, opened by the browser.  The RealtimePort encapsulates the functions necessary to perform an ICE negotiation [[!RFC5245]].  In ICE terms, a <code><a>RealtimePort</a></code> is a local candidate.
            </li>
            <li>
              The <code><a>RealtimeTransport</a></code> is a peer-to-peer bearer for secured media.  It binds a local <code><a>RealtimePort</a></code> to a remote <code><a>RealtimePort</a></code> and enables the bidirectional exchange of media packets.
            </li>
          </ul>
        </p>
        <p>
          In order to establish a transport between a local peer and remote peer, the following process is applied:
          <ol>
            <li>
              The local peer opens one or more real-time ports.
            </li>
            <li>
              The local peer then has to learn of the ports that its remote peer has opened.  This uses a signaling channel specific to the application.  For instance, a web application could use previously HTTP requests or Websockets connections for this purpose.
            </li>
            <li>
              A testing process is used to find a local and remote port pair (a candidate pair) that can exchange UDP packets.  One or more connectivity checks are made from different local ports toward different remote ports.  A successful connectivity check indicates that packets can reach the peer and that the peer consents to receive packets.  
            </li>
            <li>
              Finally, a real-time transport is established on the pair of ports.  A security context is established so that secured media packets are able to flow in both directions between peers.  <code><a>RealtimeMediaStream</code>s can then be added to the transport.
            </li>
          </ol>
        </p>
        <p>
          In the first step of this scenario one or more <code><a>RealtimePort</a></code> objects are created in different ways.  The browser allocates a local UDP port on each of the available network interfaces and returns these to the application.
        </p>
        <pre class="example">
    RealtimePort.openLocalPorts(function(ports) {
        signalingChannel.send('candidates', ports);
        localCandidates.push(ports);
    });
        </pre>
        <p>
          Each real-time port consists of an IP address, a port number, a username fragment, a password and a priority.  This information is exchanged with the remote peer using whatever signaling mechanism is chosen by the application.
        </p>
        <p>
          Other forms of real-time port might be necessary for successful traversal of middleboxes like firewalls and NATs.  For instance, a relay port (i.e., relay candidate) uses a relay server to forward packets.  Because the relay server is publically reachable, many of the concerns with middlebox traversal do not apply to it, enabling communication in more challenging network conditions.
        </p>
        <pre class="example">
    RealtimePort.allocateRelay(relay, function(error, relayCandidates) {
        if (!error) {
            signalingChannel.send('candidate', relayCandidate);
        }
    });
        </pre>
        <p>
          Local and remote real-time ports are paired and connectivity checking is used for each pair to determine which ports can be used for exchanging packets.
        </p>
        <pre class="example">
    function receivePeerCandidates(remotePorts) {
        var candidatePairs = localCandidates.forEach(function(local) {
            local.addEventListener('checksuccess', checkSuccessCallback);
            return remotePorts.forEach(function(remote) {
                local.check(remote);
            });
        });
    }
        </pre>
        <p>
          Of the successful connectivity checks, one or more pairs are selected.  A <code><a>RealtimeTransport</a></code> is then created from the pair of ports.
        </p>
        <pre class="example">
    function checkSuccessCallback(event) {
        var local = event.target;
        var remote = event.remote;
        RealtimeTransport.createTransport(local, remote, options, function(err, transport) {
            realtimeTransport = transport;
        });
    }
        </pre>
        <p>
          The resulting transport object can be used to securely exchange media with the peer.
        </p>
      </section>
    </section>

    <section id='builder'>
      <h2>Real-Time Transport Builder</h2>
      <p>
        A real-time transport builder provides an application with an ICE implementation that produces a <code><a>RealtimeTransport</a></code> with minimal effort.  The <code><a>RealtimeTransportBuilder</a></code> uses the <code><a>RealtimePort</a></code> API, and provides a means for the application to inspect, control or interrupt the ongoing ICE setup.
      </p>
      <p>
        Additional options for <code>RealtimeTransportBuilder</code> include optional STUN and TURN servers, plus control over whether this peer is in the ICE controlling or controlled role.
      </p>

      <section>
        <h3>The <code>RealtimeTransportBuilder</code> Object</h3>
        <p>
          A <code><dfn>RealtimeTransportBuilder</dfn></code> is responsible for constructing a peer-to-peer transport using ICE.
        </p>
        <dl title="[Constructor(RealtimeTransportBuilderOptions options)] interface RealtimeTransportBuilder : EventTarget" class="idl">
          <dt>readonly attribute sequence&lt;RealtimePort&gt; local</dt>
          <dd>
            The set of gathered <code>RealtimePort</code>s in priority order (highest priority first).  These ports can be interacted with directly.
          </dd>
          <dt>readonly attribute sequence&lt;RemoteRealtimePort&gt; remote</dt>
          <dd>
            The set of <code>RemoteRealtimePort</code>s provided to the <code>addRemote()</code> method, sorted in priority order.
          </dd>
          <dt>readonly attribute RealtimeTransport? transport</dt>
          <dd>
            The current active transport, if one has been successfully created.  This value will be <code>null</code> prior to the successful completion of processing.
          </dd>
          <dt>void start()</dt>
          <dd>
            <p>Starts or restarts the transport builder.  The transport builder will perform the ICE process as though for a single component.</p>
            <p>It is possible invoke this method multiple times, where each subsequent invocation triggers a restart of ICE processing.  While running, the builder will automatically restart the process if it detects network events that necessitate a restart.
          </dd>
          <dt>void addRemote(RemoteRealtimePort remotePort)</dt>
          <dd>
            Adds information about a remote port to the transport builder.
          </dd>
          <dt>void stop()</dt>
          <dd>
            Stops the transport builder.  Any ports or transports that may have been opened while the builder was running remain open and can continue to be used.
          </dd>
          <dt>void closeAll()</dt>
          <dd>
            Stops the builder and closes all ports and transports that may have been created.
          </dd>
          <dt>[TreatNonCallableAsNull] attribute RealtimeTransportConnectEventHandler? onconnect</dt>
          <dd>
            The <code>connect</code> event is fired when a transport is successfully created.  This event could fire multiple times during the operation of the transport builder if a transport with a higher priority is selected, or network changes cause the current transport to fail.
          </dd>
          <dt>[TreatNonCallableAsNull] attribute RealtimePortEventHandler? onport</dt>
          <dd>
            The <code>port</code> event is fired when a local port is gathered.
          </dd>
          <dt>attribute EventHandler onerror</dt>
          <dd>
            The <code>error</code> is fired by a transport builder when no candidates can be gathered or when transport creation fails.
          </dd>
        </dl>
        
        <section>
          <h4>The <code>RealtimeTransportBuilderOptions</code> Dictionary</h4>
          <p>
            A <code><dfn>RealtimeTransportBuilderOptions</dfn></code> contains all the information necessary to establish a peer-to-peer transport using <code>RealtimeTransportBuilder</code>.  All values, except <code>transport</code> are optional.
          </p>
          <dl title="dictionary RealtimeTransportBuilderOptions" class="idl">
            <dt>RealtimeTransportOptions transport</dt>
            <dd>
              Options to use in the creation of a <code><a>RealtimeTransport</a></code>.
            </dd>
            <dt>RemoteRealtimePort stun = null</dt>
            <dd>
              A STUN server from which to collect server reflexive addresses.
            </dd>
            <dt>RemoteRealtimePort turn = null</dt>
            <dd>
              A TURN server from which to allocate relay ports.
            </dd>
            <dt>boolean controlling = false</dt>
            <dd>
              This options is set to true if this peer should assume that it is acting in the ICE controlling role.  ICE role conflict resolution is used to ensure that a misunderstanding about role does not prevent a transport from being established.
            </dd>
            <dt>long roundTrip = 500</dt>
            <dd>
              An initial estimate of the round trip time between the peers, in milliseconds.  This value sets the ICE RTO.  The final RTO value will be adjusted (but not below 100) based on the observed round trip time.
            </dd>
            <dt>long maxChecks = 5</dt>
            <dd>
              The maximum number of checks to generate for each port (or candidate) pair before considering a connectivity check transaction to have failed.
            </dd>
            <dt>sequence&lt;StunAttribute&gt; attributes = []</dt>
            <dd>
              A set of additional STUN attributes to add to connectivity check requests that are made toward peers.
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>RealtimeTransportConnectEventHandler</code> Callback Function</h4>

          <p>
            This callback is invoked when a transport builder successfully creates a transport.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-RealtimeTransportConnectEventHandler" class="idlCallback">callback <span class="idlDictionaryID">RealtimeTransportConnectEventHandler</span> = void (<span class="idlParamType"><a class="idlType" href="#idl-def-RealtimeTransportConnectEvent">RealtimeTransportConnectEvent</a></span> <span class="idlParamName">event</span>);</span>
          </pre>
        </section>

        <section>
          <h4>The <code>RealtimeTransportConnectEvent</code> Interface</h4>

          <p>
            The <code><dfn>RealtimeTransportConnectEvent</dfn></code> event object passed to the <code>RealtimeTransportConnectEventHandler</code> includes the transport that was created.
          </p>

          <dl title="[Constructor(RealtimeTransportConnectEventInit)] interface RealtimeTransportConnectEvent : Event" class="idl">
            <dt>attribute RealtimeTransport transport</dt>
            <dd>
              The <code><a>RealtimeTransport</a></code> that was connected by the transport builder.
            </dd>
          </dl>
          <dl title="dictionary RealtimeTransportConnectEventInit : EventInit" class="idl">
            <dt>attribute RealtimeTransport transport</dt>
            <dd>
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>RealtimePortEventHandler</code> Callback Function</h4>

          <p>
            This callback is invoked when a transport builder opens, discovers or allocates a local port.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-RealtimePortEventHandler" class="idlCallback">callback <span class="idlDictionaryID">RealtimePortEventHandler</span> = void (<span class="idlParamType"><a class="idlType" href="#idl-def-RealtimePortEvent">RealtimePortEvent</a></span> <span class="idlParamName">event</span>);</span>
          </pre>
        </section>

        <section>
          <h4>The <code>RealtimePortEvent</code> Interface</h4>

          <p>
            The <code><dfn>RealtimePortEvent</dfn></code> event object passed to the <code>RealtimePortEventHandler</code> includes the port that was opened.
          </p>

          <dl title="[Constructor(RealtimePortEventInit)] interface RealtimePortEvent : Event" class="idl">
            <dt>attribute RealtimePort port</dt>
            <dd>
              The <code><a>RealtimePort</a></code> that was opened, discovered, or allocated (i.e., gathered) by the transport builder.  This could be a <a href="allocateRelay">relayed</a> or reflexive candidate.  Relayed or reflexive candidates that include a specific base port implement the <code><a>DerivedRealtimePort</a></code> interface, which includes the <code>base</code> attribute.  Relayed ports that use transports other than UDP do not include <code>base</code> attribute.
            </dd>
          </dl>
          <dl title="dictionary RealtimePortEventInit : EventInit" class="idl">
            <dt>attribute RealtimePort port</dt>
            <dd>
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>DerivedRealtimePort</code> Interface</h4>

          <p>
            The <code><dfn>DerivedRealtimePort</dfn></code> interface is used by the <code><a>RealtimeTransportBuilder</a></code> to provide information on the base for derived candidates.  This includes server reflexive, peer reflexive and UDP relay candidates.
          </p>
          <p>
            Reflexive candidates that implement this interface do not provide any events relating to connectivity checking.  Connectivity checking events are provided on the corresponding base port.  Relayed ports provide a complete implementation.
          </p>

          <dl title="[NoInterfaceObject] interface DerivedRealtimePort" class="idl">
            <dt>attribute RealtimePort base</dt>
            <dd>
              The <code><a>RealtimePort</a></code> that this object was derived from.  The <code>base</code> provides information necessary to distinguish unique candidates in some unusual network configurations.
            </dd>
          </dl>
          <p><code>DerivedRealtimePort</code> implements <code><a>RealtimePort</a></code>:</p>
          <pre class="pseudoidl">
<span class="idlDictionaryID"><a>DerivedRealtimePort</a></span> implements <span class="idlDictionaryID"><a>RealtimePort</a></span>;
          </pre>
        </section>
      </section>

    </section>


    <section>
      <h2>Real-Time Transport</h2>
      
      <p>
        A <code><dfn>RealtimeTransport</dfn></code> represents the flow of packets between a local and a remote real-time port.
      </p>
      <p>
        Upon creation, a <code><a>RealtimeTransport</a></code> beings automatically generating connectivity checks toward the selected remote peer.  If a consent check fails, the transport remains open, but no packets can be sent.
      </p>

      <section>
        <h3>The <code>RealtimeTransport</code> Object</h3>
        <dl title="interface RealtimeTransport : EventTarget" class="idl">
          <dt>static void createTransport (RealtimePort local, RemoteRealtimePort remote, TransportOptions options, TransportCallback callback)</dt>
          <dd>
            Factory method for creating a transport.
          </dd>
          
          <dt>readonly attribute RealtimePort localPort</dt>
          <dd>
            The local real-time port that is used for this transport.
          </dd>
          <dt>readonly attribute RemoteRealtimePort remotePort</dt>
          <dd>
            The remote real-time port that is used for this transport.
          </dd>
          <dt>readonly attribute boolean dtls</dt>
          <dd>
            Whether key negotiation for the transport is being controlled using DTLS.
          </dd>
          <dt>readonly attribute RemoteCertificateInformation? remoteCertificate</dt>
          <dd>
            Information about the certificate offered by the remote peer.  This attribute is only set if the transport is using DTLS for key negotiation.
          </dd>

          <dt>readonly attribute SrtpSecurityDescription? outboundSdes</dt>
          <dd>
            The SRTP security description for outbound media.
          </dd>
          <dt>readonly attribute SrtpSecurityDescription? inboundSdes</dt>
          <dd>
            The SRTP security description for inbound media.
          </dd>

          <dt>readonly attribute boolean open</dt>
          <dd>
            Whether the transport is currently open and able to receive data.  Newly created transports always start with this value set to <code>true</code>.  Note that absence or expiry of consent from the remote peer can cause a transport to be unable to send on an open transport.
          </dd>
          <dt>readonly attribute unsigned long bandwidth</dt>
          <dd>
            The maximum available bandwidth on this transport, as detected by the browser.  This value can change over time.  Users of the transport operate within this envelope; packets that exceed this limit within any interval (browser-selected) are discarded.
          </dd>
          <dt>void close()</dt>
          <dd>
            This closes the transport.
          </dd>
          <dt>attribute EventHandler onclose</dt>
          <dd>
            The <code>close</code> event is fired when the transport is closed.
          </dd>
          <dt>readonly attribute boolean consent</dt>
          <dd>
            Whether the transport is currently open and able to send data.  This depends on there being a successful consent check toward the remote peer within a browser-configured period.  This valid is <code>false</code> when consent toward the remote peer has expired.
          </dd>
          <dt>attribute EventHandler onconsent</dt>
          <dd>
            This <code>consent</code> event is fired when consent checks toward the remote peer succeed after having failed.
          </dd>
          <dt>attribute EventHandler onconsentexpired</dt>
          <dd>
            The <code>consentexpired</code> event is fired when consent checks toward the remote peer time out and no packets are able to be sent on this transport.
          </dd>
          <dt>attribute EventHandler onbandwidthchange</dt>
          <dd>
            The <code>bandwidthchange</code> event is fired when the browser learns of a change in available bandwidth on the transport.  The browser MAY limit the rate of notifications, or suppress notification for small (10% or less) changes in available bandwidth.
          </dd>
          <dt>attribute unsigned long? inactivityInterval</dt>
          <dd>
            This attribute can be set to determine when the <code>oninactive</code> event is fired.
          </dd>
          <dt>attribute EventHandler oninactive</dt>
          <dd>
            The <code>inactive</code> event is fired when the transport has been inactive for <code>inactivityInterval</code> milliseconds.  That is, the time since the last packet was received from the peer exceeds the specified time.
          </dd>
          <dt>[TreatNonCallableAsNull] attribute UnknownSsrcEventHandler? onunknownssrc</dt>
          <dd>
            <p>
              The <code>unknownssrc</code> event is fired when an RTP packet arrives on the transport without a corresponding <code><a>RealtimeMediaStream</a></code>.  Applications that do not signal SSRCs can use this event to recognize a new or changed SSRC and trigger the addition or modification of streams.  
            </p>
            <p>
              The browser MUST buffer packets that arrive with the SSRC until all event handlers have returned or until a <code>RealtimeMediaStream</code> is created to accept the incoming data.  This allows an application to ensure that packets are not lost due to SSRC renumbering or absence of SSRC in signaling.
            </p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>Transport Creation Options</h3>
        <p>
          Specifying <code><dfn>RealtimeTransportOptions</dfn></code> can be used to alter the characteristics of a transport.
        </p>
        <dl title="dictionary RealtimeTransportOptions" class="idl">
          <dt>RealtimeTransportMode mode = "dtls-srtp"</dt>
          <dd>
            The mode used for the transport.
          </dd>
          <dt>SrtpSecurityDescription outboundSdes</dt>
          <dd>
            A description of the security parameters for outbound streams of RTP media secured with SRTP [[!RFC3711]].  Used only when SRTP keys are negotiated through signaling.
          </dd>
          <dt>SrtpSecurityDescription inboundSdes</dt>
          <dd>
            A description of the security parameters for inbound streams of RTP media secured with SRTP [[!RFC3711]].  Used only when SRTP keys are negotiated through signaling.
          </dd>
          <dt>DtlsRole? role</dt>
          <dd>
            The role that the local browser takes in the DTLS [[!RFC5764]] handshake, either 'client' or 'server'.
          </dd>
          <dt>CertificateValidationCallback validate</dt>
          <dd>
            This callback is triggered when the certificate for the remote peer is received.  This allows the application to accept or reject a peer based on the proffered certificate.  This is only valid for a DTLS transport.  When omitted, the certificates is automatically accepted.
          </dd>
          <dt>sequence&lt;DOMString> cipherSuites</dt>
          <dd>
            A set of DTLS cipher suites that can be negotiated for DTLS, using the <q>Description</q> from the <a href="http://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-3">TLS cipher suite registry</a>.  The browser cannot negotiate any suite that is not included in this set.
          </dd>
        </dl>

        <section>
          <h4>Real-Time Transport Modes</h4>
          <p>
            </p>
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-RealtimeTransportMode">RealtimeTransportMode</a></span> {
    "<a href="#widl-RealtimeTransportMode-srtp">srtp</a>", "<a href="#widl-RealtimeTransportMode-dtls-srtp">dtls-srtp</a>"
};
          </pre>
          <!-- <dl title="enum DtlsRole" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-RealtimeTransportMode-srtp"><code>srtp</code></dt>
            <dd>
              Instructs the browser to create a <code><a>RealtimeTransport</a></code> using SRTP.  When this option is chosen, the <code><a>RealtimeTransportOptions</a></code> MUST also include <code><a href="#widl-RealtimeTransportOptions-outboundSdes">outboundSdes</a></code> and <code><a href="#widl-RealtimeTransportOptions-inboundSdes">inboundSdes</a></code>.
            </dd>
            <dt id="widl-RealtimeTransportMode-dtls-srtp"><code>dtls-srtp</code></dt>
            <dd>
              Instructs the browser to create a <code><a>RealtimeTransport</a></code> using DTLS-SRTP [[!RFC5764]].  When this option is chosen, the <code><a>RealtimeTransportOptions</a></code> MUST also include <code><a href="#widl-RealtimeTransportOptions-role">role</a></code> and it SHOULD include <code><a href="#widl-RealtimeTransportOptions-validate">validate</a></code>.
            </dd>
          </dl>
        </section>

        <section>
          <h4>DTLS Roles</h4>
          <p>
            DTLS Roles are applicable when creating a transport over DTLS.  This option determines whether the local browser is in the client or server role.
          </p>
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-DtlsRole">DtlsRole</a></span> {
    "<a href="#widl-DtlsRole-client">client</a>", "<a href="#widl-DtlsRole-server">server</a>"
};
          </pre>
          <!-- <dl title="enum DtlsRole" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-DtlsRole-client"><code>client</code></dt>
            <dd>
              Instructs the browser to act as a DTLS server when creating a <code><a>RealtimeTransport</a></code>.  The browser acts as a DTLS client and initiates the DTLS handshake.
            </dd>

            <dt id="widl-DtlsRole-server"><code>server</code></dt>
            <dd>
              Instructs the browser to act as a DTLS server when creating a <code><a>RealtimeTransport</a></code>.  The browser waits for the remote peer to initiate the DTLS handshake.
            </dd>
          </dl>
        </section>

        <section>
          <h4>Certificate Validation Callback</h4>
          <p>
            This callback method is invoked when a DTLS transport is being created.  It allows the application to block the creation of a new transport based on the identity of the peer.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-CertificateValidationCallback" class="idlCallback">callback <span class="idlDictionaryID">CertificateValidationCallback</span> = boolean (<span class="idlParamType">RemoteCertificateInformation</span> <span class="idlParamName">remoteCertificate</span>);</span>
          </pre>
          <p>
            The callback is passed information about the certificate offered by the remote peer.  The application can make a decision based on this and either return <code>true</code> to indicate that the transport creation should proceed, or <code>false</code> to indicate that the transport creation should be aborted.
          </p>
        </section>

        <section>
          <h4>Certificate Information</h4>
          <p>
            Information about an X.509 certificate, as used with DTLS.
          </p>
          <p>
            This is another candidate for moving to another working group.
          </p>
          <p class="note">
            Users are expected to make their own determination about trustworthiness based on the feedback information presented in browser chrome.  Certificate information allows application developers a better way of building more trustworthy applications.
          </p>
          <dl title="interface CertificateInformation" class="idl">
            <dt>static CertificateInformation getLocalCertificate()</dt>
            <dd>
              This method retrieves the certificate that the browser will use for creating real-time transport.  The application can use this information to signal to peers.
            </dd>
            
            <dt>readonly attribute ArrayBuffer certificate</dt>
            <dd>
              The DER-encoded certificate information.
            </dd>
            <dt>readonly attribute DOMString subject</dt>
            <dd>
              The subject of the certificate, using the string encoding from RFC 4514.
            </dd>
            <dt>readonly attribute CertificateFingerprints fingerprint</dt>
            <dd>
              A dictionary containing fingerprints for the certificate.  Keys are the <a href="http://www.iana.org/assignments/hash-function-text-names/hash-function-text-names.xml">textual name for the hash function</a>; the corresponding value for each is an <code>ArrayBuffer</code> containing the value of the fingerprint.  Browsers MUST implement SHA-1 (<code>sha-1</code>) and SHA-2 256 (<code>sha-256</code>).
            </dd>
          </dl>
        </section>

        <section>
          <h4>Remote Certificate Information</h4>
          <p>
            Information about a remotely proffered X.509 certificate, which includes all the basic certificate information, plus fields that reveal what knowledge the browser has about trust (for instance, is this a valid domain certificate).
          </p>
          <p>For example, an application might register the following <code>CertificateValidationCallback</code> to check that it is talking to the expected domain:
          </p>
          <pre class="example">
function validateCertificate(certInfo) {
    return certInfo.isValidForDomain('example.com');
}
          </pre>

          <dl title="[NoInterfaceObject] interface RemoteCertificateInformation : CertificateInformation" class="idl">
            <dt>boolean isValidForDomain(DOMString domainName)</dt>
            <dd>
              This method returns true iff the certificate chains to one of the trust anchors configured in the browser for the specified domain name.  This allows an application to validate that a peer is offering a valid certificate for its domain.
            </dd>
          </dl>
        </section>

        <section>
          <h4>SRTP Security Descriptions</h4>
          <p>
            This dictionary describes the parameters necessary to interoperably configure an SRTP stream.  Default values are the defaults defined in [[!RFC3711]].
          </p>
          <dl title="dictionary SrtpSecurityDescription" class="idl">
            <dt>DOMString encrypt = "AES-CM"</dt>
            <dd>
              The SRTP cipher to use for encrypting packets.
            </dd>
            <dt>boolean encryptRtp = true</dt>
            <dd>
              Whether to encrypt RTP packets on this flow.
            </dd>
            <dt>boolean encryptRtcp = true</dt>
            <dd>
              Whether to encrypt RTCP packets on this flow.
            </dd>
            <dt>unsigned short keystreamPrefix = 0</dt>
            <dd>
              The number of bits to reserve from the keystream for use in authenticating each encoded packet.
            </dd>
            <dt>DOMString authenticate = "HMAC-SHA1"</dt>
            <dd>
              The packet authentication algorithm used.
            </dd>
            <dt>unsigned short n_a = 160</dt>
            <dd>
              The number of bits in the authentication output.
            </dd>
            <dt>unsigned short n_tag = 80</dt>
            <dd>
              The number of bits from the authentication output to append to the packet.
            </dd>
            <dt>DOMString keyDerivation = "AES-CM"</dt>
            <dd>
              The algorithm to use for key derivation.
              </dd>
            <dt>unsigned long keyDerivationInterval = 0</dt>
            <dd>
              The packet index at which new keys are derived.  A value of 0 indicates that new keys are never derived.
            </dd>
            <dt>ArrayBuffer key</dt>
            <dd>
              The master key.  The size of this ArrayBuffer determines <code>n_a</code>.
            </dd>
            <dt>ArrayBuffer salt</dt>
            <dd>
              The master salt.  The size of this ArrayBuffer determines <code>n_s</code>.
            </dd>
            <dt>unsigned long? windowSizeHint</dt>
            <dd>
              A hint to a receiver that indicates how large a replay protection window it is requested to maintain.  This value MAY be ignored.
            </dd>
            <dt>unsigned long long rtpPacketCount = 281474976710656</dt>
            <dd>
              The number of packets that can be safely encrypted using this scheme for RTP.  Default value of 2<sup>48</sup>.
            </dd>
            <dt>unsigned long long rtcpPacketCount = 2147483648</dt>
            <dd>
              The number of packets that can be safely encrypted using this scheme for RTCP.  Default value of 2<sup>31</sup>.
            </dd>
            <dt>ArrayBuffer? mki</dt>
            <dd>
              The optional master key index.  The size of the ArrayBuffer determines the size.
            </dd>
          </dl>
        </section>
      </section>

      <section>
        <h3>Transport Creation Callback</h3>
        <p>
          This callback function is invoked when a transport is created.
        </p>
        <pre class="pseudoidl">
<span id="idl-def-TransportCallback" class="idlCallback">callback <span class="idlDictionaryID">TransportCallback</span> = void (<span class="idlParamType">DOMString</span> <span class="idlParamName">error</span>, <span class="idlParamType">RealtimeTransport</span> <span class="idlParamName">transport</span>);</span>
        </pre>
        <p>
          The callback is called when a <code>RealtimeTransport</code> is created.
        </p>
        <p>
          If the transport creation was successful, the <code>error</code> argument is <code>null</code> and the <code>transport</code> argument contains the newly created <code>RealtimeTransport</code>.
        </p>
        <p>
          If the creation was unsuccessful, the <code>error</code> argument contains a string describing the error and the <code>transport</code> argument is <code>null</code>.
        </p>
      </section>

      <section>
        <h3>Unknown SSRC Event Handler</h3>
        <p>
          This event handler is invoked when an SSRC for which there is no corresponding <code><a>RealtimeMediaStream</a></code> is observed.
        </p>
        <pre class="pseudoidl">
<span id="idl-def-UnknownSsrcEventHandler" class="idlCallback">callback <span class="idlDictionaryID">UnknownSsrcEventHandler</span> = void (<span class="idlParamType">UnknownSsrcEvent</span> <span class="idlParamName">event</span>);</span>
        </pre>
      </section>

      <section>
        <h3>Unknown SSRC Event</h3>
        <p>
          This event indicates that an SSRC arrived for which there was no corresponding RTP stream.
        </p>
        <dl title="[Constructor(UnknownSsrcEventInit)] interface UnknownSsrcEvent : Event" class="idl">
          <dt>attribute unsigned long ssrc</dt>
          <dd>
            The SSRC of the unrecognized packet.
          </dd>
        </dl>
        <dl title="dictionary UnknownSsrcEventInit : EventInit" class="idl">
          <dt>attribute unsigned long ssrc</dt>
          <dd>
            The SSRC of the unrecognized packet.
          </dd>
          <dt>attribute byte packetType</dt>
          <dd>
            The packet type of the unrecognized packet.  This can help with packet demultiplexing if the SSRC is not already known.
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Real-Time Ports</h2>
      <p>
        A <code><dfn>RealtimePort</dfn></code> object represents an open UDP port.  The <code><a>RealtimePort</a></code> also encapsulates all the information necessary to find and use that port.
      </p>

      <section>
        <h3>The <code>RemoteRealtimePort</code> Object</h3>

        <p>
          The <code><dfn>RemoteRealtimePort</dfn></code> object is used to describe a remote real-time port.  It is a simple dictionary of values, sufficient to describe how to connect to a remote peer.
        </p>

        <dl title="dictionary RemoteRealtimePort" class="idl">
          <dt>DOMString ip</dt>
          <dd>
            The IP address (v4 or v6) for the real-time port.
          </dd>

          <dt>[EnforceRange] unsigned short port</dt>
          <dd>
            The UDP port number for the real-time port.
          </dd>

          <dt>DOMString ufrag</dt>
          <dd>
            The ICE username fragment for the port.
          </dd>
          <dt>DOMString username</dt>
          <dd>
            The username is used to specify the STUN <code>USERNAME</code> attribute explicitly.  If present, this parameter is used in preference to the username fragment.  See <a>server reflexive address</a>es for an explanation of this parameter.
          </dd>

          <dt>DOMString pwd</dt>
          <dd>
            The ICE password for the candidate.  This should be set unless this is being used to describe a STUN or TURN server that doesn't require authentication.
          </dd>
          <dt>unsigned long priority = 0</dt>
          <dd>
            The ICE priority for the candidate.
          </dd>
        </dl>

      </section>

      <section>
        <h3>The <code>RealtimePort</code> Object</h3>
        
        <p>
          A local <code><a>RealtimePort</a></code> provides limited access to the browsers STUN [[!RFC5389]] implementation which provides a means to trigger connectivity checking, the gathering of server reflexive addresses and allocation of TURN relays.
        </p>

        <p>
          The application cannot select or alter the values chosen for local ports.  The browser MAY select any UDP port number, and MUST select values for ufrag and pwd that have sufficient random entropy that they cannot be easily guessed.  This guarantees that only entities that receive this information are able to successfully make a connectivity check.  It also allows peers to identify unique browsers.
        </p>

        <dl title="interface RealtimePort : EventTarget" class="idl">
          <dt>readonly attribute DOMString ip</dt>
          <dd>
            The IP address (v4 or v6) for the real-time port.
          </dd>

          <dt>readonly attribute unsigned short port</dt>
          <dd>
            The UDP port number for the real-time port.
          </dd>

          <dt>readonly attribute DOMString ufrag</dt>
          <dd>
            The ICE username fragment for the port.
          </dd>

          <dt>readonly attribute DOMString pwd</dt>
          <dd>
            The ICE password for the port.
          </dd>

          <dt>readonly attribute unsigned long priority</dt>
          <dd>
            The ICE priority for the candidate.  This priority allows for prioritization of checks.  This parameter is added to all checks sent by the candidate.
          </dd>

          <dt>static void openLocalPorts (RealtimePortCallback callback)</dt>
          <dd>
            Open ports on the local host.  One <code><a>RealtimePort</a></code> is opened for each network interface on the host.  Calls the provided callback when complete, passing the ports that were opened as a result of the function call.  Ports are provided to the callback in priority order.
          </dd>

          <dt>static void allocateRelay (TurnServer turnServer, RealtimePortCallback callback)</dt>
          <dd>
            <a href="allocateRelay">Allocate a relay port on a TURN server</a> using a newly created local base.
          </dd>
          <dt>void allocateRelay (TurnServer turnServer, RelayCallback callback)</dt>
          <dd>
            <a href="allocateRelay">Allocate a relay port on a TURN server</a> over UDP using this local real-time port as the base.
          </dd>
          
          <dt>[TreatNonCallableAsNull] attribute EventHandler onnetworkchange</dt>
          <dd>
            An event handler for being informed of <a href="#networkchange">changes to network connectivity</a>.  <b>Note</b>: This is a candidate for moving to <code>navigator</code> or even the <a href="http://www.w3.org/TR/netinfo-api/">network information API</a>.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onchecksent</dt>
          <dd>
            Called when a <a href="#checking">connectivity check</a> is sent to a remote peer.  The event passed MUST NOT include the STUN Binding request.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onchecksuccess</dt>
          <dd>
            Called when a valid <a href="#checking">connectivity check</a> response is received from a remote peer.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute ConnectivityCheckEventHandler? onremotecheck</dt>
          <dd>
            Called when a remote peer <a href="#serving">successfully performs a connectivity check</a> against this port.
          </dd>

          <dt>void setServerAttributes(sequence<StunAttribute> serverAttributes)</dt>
          <dd>
            Define a set of attributes that the port will add to STUN Binding check responses.  Attributes with a value will be sent verbatim, attributes with no value set will be echoed from the request, but only if the request includes that attribute.
          </dd>

          <dt>readonly attribute sequence<StunAttribute> serverAttributes</dt>
          <dd>
            The set of attributes that the port will add to STUN Binding check responses.
          </dd>

          <dt>[TreatNonCallableAsNull] attribute EventHandler onclose</dt>
          <dd>
            Invoked when the real-time port is closed.
          </dd>

          <dt>readonly attribute boolean open</dt>
          <dd>
            Whether the port is open and can be used.  This attribute is <code>true</code> when the object is passed to the application and <code>false</code> after the <a>close</a> method is invoked.
          </dd>

          <dt>long check (RemoteRealtimePort remote, optional StunAttribute... attributes)</dt>
          <dd>
            Perform a <a href="#checking">connectivity check</a> on the remote port.  Returns a handle on the check that can be used to <a href="#widl-RealtimePort-cancelCheck">cancel</a> it.
          </dd>

          <dt>void cancelCheck (long checkHandle)</dt>
          <dd>
            Cancel an outstanding or enqueued connectivity check.  This guarantees that a <code><a>onchecksuccess</a></code> event is never triggered for the specified check.
          </dd>

          <dt>boolean status (RemoteRealtimePort remoteRealtimePort)</dt>
          <dd>
            Query the status of a particular remote port with respect to this port.  Returns <code>true</code> iff the remote port was successfully checked recently.  The specific time is based on the browser's configured consent expiration timer.
          </dd>

          <dt>void close ()</dt>
          <dd>
            Closes the port and any associated open transports that use the port.
          </dd>
        </dl>

        <section>
          <h4>The <code>RealtimePortCallback</code> Callback</h4>
          <p>
            The <code><dfn>RealtimePortCallback</dfn></code> callback function is passed to <code><a>openLocalPorts</a></code> or <code><a>allocateRelay</a></code>.   When the port is either successfully opened, or opening fails, the callback is invoked.  Opening local ports cannot fail.  Allocating a TURN relay port creates a single port.
          </p>
          <pre class="pseudoidl">
<span id="idl-def-RealtimePortCallback" class="idlCallback">callback <span class="idlDictionaryID">RealtimePortCallback</span> = void (<span class="idlParamType">DOMString?</span> <span class="idlParamName">error</span>, <span class="idlParamType">sequence&lt;<a class="idlType" href="#idl-def-RealtimePort">RealtimePort</a>></span> <span class="idlParamName">ports</span>);</span>
          </pre>
          <p>
            The error parameter is set to <code>null</code> unless the allocation fails, in which case it contains a <code>DOMString</code> that explains the reasons for the error.  (Ed: Need to specify error code values here.)
          </p>
        </section>
        
        <section>
          <h4>The <code>ConnectivityCheckEventHandler</code> Callback Function</h4>

          <p>
            This callback is invoked with an event whenever a connectivity check event occurs.  This is tied to the following events:
            <ul>
              <li>
                <b><code>onremotecheck</code></b>&mdash;when a valid connectivity check is made by a remote peer
              </li>
              <li>
                <b><code>onchecksent</code></b>&mdash;when a connectivity check is made by the browser
              </li>
              <li>
                <b><code>onchecksuccess</code></b>&mdash;when a connectivity check succeeds
              </li>
            </ul>
          </p>
          <pre class="pseudoidl">
<span id="idl-def-ConnectivityCheckEventHandler" class="idlCallback">callback <span class="idlDictionaryID">ConnectivityCheckEventHandler</span> = void (<span class="idlParamType"><a class="idlType" href="#idl-def-ConnectivityCheckEvent">ConnectivityCheckEvent</a></span> <span class="idlParamName">event</span>);</span>
          </pre>
        </section>

        <section>
          <h4>The <code>ConnectivityCheckEvent</code> Interface</h4>

          <p>
            The event object passed to the <code>ConnectivityCheckEventHandler</code> includes a target of the local port, the remote port and information on the STUN Binding request and Binding response messages that triggered the event.  
          </p>
          <p>
            The <code>onchecksent</code> event does not include either STUN message because revealing the STUN transaction identifier chosen by the browser could allow a web attacker to spoof a response.
          </p>

        <dl title="[Constructor(ConnectivityCheckEventInit)] interface ConnectivityCheckEvent : Event" class="idl">
          <dt>attribute RemoteRealtimePort remote</dt>
          <dd>
            This identifies the remote port involved in this connectivity check.  For incoming checks, the remote port information only includes <code>ip</code> and <code>port</code>.
          </dd>
          
          <dt>attribute StunBinding? request</dt>
          <dd>
            For the <code>onchecksuccess</code> and <code>onremotecheck</code> events, this includes the STUN Binding request that was respectively sent or received.  For the <code>onchecksent</code> event, this attribute is <code>null</code>.
          </dd>

          <dt>attribute StunBinding? response</dt>
          <dd>
            For the <code>onchecksuccess</code> and <code>onremotecheck</code> events, this includes the STUN Binding response that was respectively received or sent.  For the <code>onchecksent</code> event, this attribute is <code>null</code>.
          </dd>
        </dl>
        <dl title="dictionary ConnectivityCheckEventInit : EventInit" class="idl">
          <dt>attribute RemoteRealtimePort remote</dt>
          <dd>
          </dd>
          
          <dt>attribute StunBinding? request</dt>
          <dd>
          </dd>

          <dt>attribute StunBinding? response</dt>
          <dd>
          </dd>
        </dl>
        </section>
      </section>
      
      <section>
        <h3><code>RealtimePort</code> Lifecycle</h3>
        <p>
          A local <a>RealtimePort</a> is created by the browser in response to a call to <code><a href="#widl-RealtimePort-openLocalPorts">openLocalPorts</a>(<var>callback</var>)</code> or <code><a href="#widl-RealtimePort-allocateRelay-static-void-TurnServer-turnServer-RealtimePortCallback-callback">allocateRelay</a>(<var>callback</var>)</code>.  Each RealtimePort is given to the application with the open attribute set to true. 
        </p>

        <section id="openLocalPorts">
          <h4>Opening Local Ports</h4>
          <p>
            Host-local ports (host candidates in ICE) are UDP ports that are opened on the local host.  These ports are opened by the browser in response to a call to <code><a>RealtimePort</a>.<a href="#widl-RealtimePort-openLocalPorts">openLocalPorts</a>(<var>callback</var>)</code>.
          </p>

          <p class="note">
            The username fragment and password used in ICE is normally global.  That is, the same values are shared for all candidates in the same session.  Browsers that wish to interoperate with non-browser peers SHOULD provide the same value for ufrag and pwd as a result of each request to open local ports.
          </p>
        </section>

        <section>
          <h4>Discovering Server Reflexive Addresses</h4>
          <p>
            A <dfn>server reflexive address</dfn> is the addressing information for a given port, as seen by a server.  The server reports the address that it sees when the browser sends it a packet.  Where there are network address translation (NAT) middleboxes between the browser and the server, this reveals the translated address at the NAT, a value that might be undetectable from the browser.
          </p>
          <p>
            Server reflexive addresses are gathered by making connectivity checks to STUN servers from a specific local real-time port.  The server provides the address that it sees in the <code>XOR-MAPPED-ADDRESS</code> attribute of the response.
          </p>
          <p>Using a server reflexive address ultimately results in packets arriving at the corresponding host-local port.  Therefore, server reflexive addresses do not require the creation of additional <code><a>RealtimePort</a></code> objects in the browser.
          </p>
          <p>
            The <a href="#checking">connectivity check</a> interface is used to send queries to STUN servers.  When querying a STUN server, the <code><a>RemoteRealtimePort</a></code> can include several variations on the set of included options:
            <ul>
              <li>
                An ICE-compatible <a href="#checking">connectivity check</a> is invoked by providing ICE username fragment and password parameters.  The STUN <code>USERNAME</code> attribute is populated by concatenating the remote username fragment (<code><var>remotePort</var>.ufrag</code>), a colon character (':') and the local username fragment.  The <code>MESSAGE-INTEGRITY</code> attribute is created using the remote password (<code><var>remotePort</var>.pwd</code>) as described in [[!RFC5389]].
              </li>
              <li>
                A <var>username</var> parameter can be provided in place of <var>ufrag</var>.  The browser uses the value of <var>username</var> for the STUN <code>USERNAME</code> attribute.  <code>MESSAGE-INTEGRITY</code> is filled as normal.
              </li>
              <li>
                Both <var>ufrag</var> and <var>username</var> can be omitted to suppress the inclusion of the <code>USERNAME</code> attribute.
              </li>
              <li>
                <var>pwd</var> can be omitted to suppress the inclusion of the <code>MESSAGE-INTEGRITY</code> attribute.
              </li>
            </ul>
          </p>
          <p>
            A port pair is only marked as having active consent if the ICE-compatible connectivity check is used.  This ensures that STUN servers cannot be bombarded with media from browsers.
          </p>
          <p>
            If long-term credentials are in use for the STUN server, as described in [[!RFC5389]], then the application is responsible for calculating the value of the password.
          </p>
        </section>

        <section id="allocateRelay">
          <h4>Allocating Relays</h4>
          <p>
            UDP relays are allocated by calling <code><a>RealtimePort</a>.<dfn>allocateRelay</dfn>(<var>turnServerRealtimePort</var>, <var>callback</var>[, <var>attributes</var>])</code>.  The browser performs a TURN [[!RFC5766]] relay allocation with the identified host and provides a relayed <code><a>RealtimePort</a></code> to the provided callback.
          </p>
          <p>
            A <var>turn</var> attribute can be set on the TURN server <code><a>RemoteRealtimePort</a></code> to select the transport used between the browser and TURN server.  The <var>turn</var> attribute takes one of three values: <code>udp</code>, <code>tcp</code>, or <code>tls</code>.  The browser uses UDP to communicate with the TURN server unless otherwise specified.  The <var>turn</var> attribute only determines the transport used between browser and TURN server; UDP is the only supported transport between the server and remote peers.
          </p>
          <p>
            Once the allocation has completed, the <var>callback</var> method is invoked.  An error parameter is set to an error code if the allocation fails.  An array containing a single <code><a>RealtimePort</a></code> parameter is provided if the allocation is successful.
          </p>
          <pre class="example">
    function createRelayCandidate() {
        var relay = { ip: '192.0.2.75', port: 7754, username: 'user', password: 'password1', turn: 'udp' };
        RealtimePort.allocateRelay(relay, function(error, relayCandidates) {
            if (error) {
                reportError(error);
            } else {
                signalingChannel.send('candidate', relayCandidate);
                scheduleConnectivityChecks(relayCandidate);
            }
        });
    }
          </pre>
          <p>
            In order to select a specific local candidate for the allocation of relays, the <code><a>allocateRelay</a></code> method can be called on a candidate instance.  This is only possible if the transport to the relay server is UDP.
          </p>
          <p>
            Application-selected attributes can be added to the allocation request, just as they can be added to <a href="#checking">connectivity checks</a>.
          </p>
          
          <dl title="dictionary TurnServer : RemoteRealtimePort" class="idl">
            <dt>TurnRelayTransport turn = "udp"</dt>
            <dd>
              The protocol to use for communication with a TURN relay.
            </dd>
          </dl>
          
          <pre class="pseudoidl">
enum <span class="idlInterfaceID"><a id="widl-TurnRelayTransport">TurnRelayTransport</a></span> {
    "<a href="#widl-TurnRelayTransport-udp">udp</a>", "<a href="#widl-TurnRelayTransport-tcp">tcp</a>", "<a href="#widl-TurnRelayTransport-tls">tls</a>"
};
          </pre>
          <!-- <dl title="[NoInterfaceObject] enum TurnRelayTransport" class="enum" data-transform="transformEnum">-->
          <dl class="attributes">
            <dt id="widl-TurnRelayTransport-udp"><code>udp</code></dt>
            <dd>
              Use UDP transport between the browser and the TURN relay server.  This is the default value.
            </dd>

            <dt id="widl-TurnRelayTransport-tcp"><code>tcp</code></dt>
            <dd>
              Use TCP transport between the browser and the TURN relay server.
            </dd>

            <dt id="widl-TurnRelayTransport-tls"><code>tls</code></dt>
            <dd>
              Use TLS over TCP transport between the browser and the TURN relay server.
            </dd>
          </dl>
        </section>
        
        <section>
          <h4>Closing Real-Time Ports</h4>
          <p>
            Real-Time ports can be closed by calling <code><a href="#widl-RealtimePort-close">close</a>()</code>.  This sets the <var>open</var> attribute to false and closes any transports that use the port.   Any attempt to invoke methods on a closed <code><a>RealtimePort</a></code> triggers an exception, except for <code>status(<var>remotePort</var>)</code> that can harmlessly return <code>false</code>.
          </p>

          <p>
            Closing a real-time port does not prevent packets from arriving, though it stops them from being seen by applications and thus connectivity checks to these ports fail.  A well-behaved remote peer will eventually stop sending when connectivity checks fail.
          </p>
        </section>
      </section>

      <section>
        <h3>Connectivity Checking</h3>
        <p>
          To establish a bidirectional transport flow between peers, both are required to successfully complete one or more connectivity check requests.  Connectivity checks are used to open ports on NAT and firewall middleboxes, to validate end-to-end connectivity and to establish that the peer is willing to receive packets.
        </p>

        <section id="checking">
          <h4>Sending Connectivity Checks</h4>
          <p>
            Applications can request the sending of a STUN Binding request to perform a connectivity check or collect additional addressing information.  The browser performs a connectivity check by sending a STUN Binding request using <code><var>port</var>.<a href="#widl-RealtimePort-check-long-RemoteRealtimePort-remote-StunAttribute-attributes">check</a>(<var>remotePort</var>, <var>callback</var>[, <var>attributes</var>])</code>.
          </p>
          <p>
            The browser invokes the callback function if the connectivity check successfully completes.  The STUN request and response messages are passed to the callback.
          </p>
          <p>
            Binding requests MUST be globally rate limited by the browser.  Any requests that cannot be immediately sent are enqueued.  A browser MAY limit the number of requests that it will enqueue; lower limits SHOULD be applied to individual origins to prevent origins from monopolizing access to this feature.
          </p>
          <p class="note">
            ICE specifies a rate limiting function that is based on the expected bandwidth of media.  Since this depends on information provided by a potential web attacker, this input cannot be used.  The browser MUST rate limit connectivity checks based only on information that cannot be influenced or altered by a web attacker.
          </p>
          <p>
            The browser is responsible for populating the STUN <code>USERNAME</code>, <code>MESSAGE-INTEGRITY</code> and <code>FINGERPRINT</code> attributes.  STUN attributes can be added or overwritten by including values in the optional <code><var>attributes</var></code> parameter.  STUN attributes specified in this manner are covered by the integrity check.  Attributes that would cause the STUN request to exceed its size limit cause an exception to be thrown.
          </p>
          <p>
            DOMString values for <code><a href="#widl-RemoteRealtimePort-ufrag">ufrag</a></code> and <code><a href="#widl-RemoteRealtimePort-pwd">pwd</a></code> are encoded using UTF-8 [[!UTF-8]] in Binding requests.
          </p>
          <p>
            Prior to the successful completion of a connectivity check, the browser MUST NOT reveal the transaction identifier to the application.  Knowing the transaction identifier of a STUN request prior to receiving a successful response would enable the spoofing of responses, potentially tricking the browser into sending media packets to an unwilling recipient.
          </p>
          <p>
            The browser MUST limit the time that an outstanding connectivity check remains valid.  However, the browser is not responsible for providing a callback when this timer expires.  The application is responsible for looking after its own timers.
          </p>
        </section>

        <section id="tracking">
          <h4>Tracking Valid Real-Time Port Pairs</h4>
          <p>
            The browser is responsible for tracking valid remote real-time port pairs.  Any time that a locally originated connectivity check succeeds, the browser marks the pair of ports (local port + remote port) as valid.  The valid marking lasts for a fixed duration.  The browser SHOULD keep a port pair valid for 40 seconds.
          </p>
          <p>
            The browser MUST NOT send anything other than a connectivity check unless the port pair is valid.  This ensures that the remote peer has consented to receive packets and that the consent is recent.
          </p>
          <p>
            The status of a port pair can be queried by using <code><var>candidate</var>.<a>status</a>(<var>remotePort</var>)</code>.  This method returns <code>true</code> if a connectivity check between the two ports succeeded recently.
          </p>
        </section>

        <section id="serving">
          <h4>Responding to Connectivity Checks</h4>
          <p>
            The browser responds to valid connectivity checks on all open ports.  Received packets that do not conform with the following rules MUST be ignored:
            <ul>
              <li>
                The packet is a STUN Binding request that contains the STUN magic cookie [[!RFC5389]].
              </li>
              <li>
                The Binding request contains a <code>USERNAME</code> attribute that starts with the browser-assigned username fragment, plus a colon (ASCII 0x3a).
              </li>
              <li>
                The Binding request contains a valid <code>MESSAGE-INTEGRITY</code> attribute that is calculated over the <code>USERNAME</code> attribute.
              </li>
              <li>
                The Binding request contains a valid <code>FINGERPRINT</code> attribute.
              </li>
            </ul>
          </p>
          <p>
            Applications can register a callback listener against a real-time port.  This function is called when a valid connectivity check is received.  The callback signature is identical to the callback for locally originated conectivity checks.  Both the request and response message are passed to the callback.
          </p>
          <p>
            Browsers respond to connectivity checks on each port that it opens.  The browser MUST limit the number of unique peers that it generates connectivity check responses for.  This ensures that the number of flows that can be created towards the browser from different browsers is limited.  This mitigates an attack where a web attacker shares open port information with multiple browsers.
          </p>
          <p>
            STUN attributes that are provided to the application MUST NOT include any attributes that are not covered by the <code>MESSAGE-INTEGRITY</code> attribute.
          </p>
        </section>

        <section>
          <h4>The <code>StunBinding</code> Object</h4>
          <p>
            The <code><dfn>StunBinding</dfn></code> object contains information necessary to construct and interpret STUN Binding requests.
          </p>
          <dl title="[NoInterfaceObject] interface StunBinding" class="idl">
            <dt>readonly attribute Date timestamp</dt>
            <dd>
              The time that the STUN Binding request or response was sent or received (respectively).
            </dd>
            <dt>readonly attribute ArrayBuffer transactionId</dt>
            <dd>
              The STUN transaction ID is selected by the browser.  This object is only provided to users once a STUN transaction has successfully completed, ensuring that STUN responses cannot be spoofed by web attackers.
            </dd>
            <dt>readonly attribute sequence&lt;StunAttribute> attributes</dt>
            <dd>
              The complete set of STUN attributes in the request in the order that they appear.  Note that attributes that appear after the <code>MESSAGE-INTEGRITY</code> are not authenticated.
            </dd>
            <dt>StunAttribute getStunAttribute(byte type)</dt>
            <dd>
              Retrieves the first appearing <code><a>StunAttribute</a></code> of the given type.  This method only returns authenticated attributes.
            </dd>
            <dt>Address getMappedAddress()</dt>
            <dd>
              A convenience method for accessing the <code>XOR-MAPPED-ADDRESS</code> attribute.  This returns a dictionary containing <code>ip</code> and <code>port</code>.
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>StunAttribute</code> Object</h4>
          <p>
            The <code><dfn>StunAttribute</dfn></code> dictionary contains a single STUN attribute.
          </p>
          <dl title="dictionary StunAttribute" class="idl">
            <dt>unsigned short type</dt>
            <dd>
              The type of the STUN attribute, see <a href="http://www.iana.org/assignments/stun-parameters/stun-parameters.xml#stun-parameters-3">the IANA STUN Attributes registry</a> for a listing of standard values.
            </dd>
            <dt>ArrayBuffer value</dt>
            <dd>
              The binary value of the STUN attribute, from 0 to 255 bytes in length.
            </dd>
          </dl>
        </section>

        <section>
          <h4>The <code>Address</code> Object</h4>
          <p>
            When referring to addressing information, the following dictionary is used.
          </p>
          <dl title="dictionary Address" class="idl">
            <dt>DOMString ip</dt>
            <dd>
              The IP address, in string form.
            </dd>
            <dt>[EnforceRange] unsigned short port</dt>
            <dd>
              The port number.
            </dd>
          </dl>
        </section>
      </section>

      <section id="networkchange">
        <h3>Network Interface Changes</h3>
        <p>
          Network interfaces are imperfect and impermanent.  They can change, appear and disappear with no warning, especially on mobile devices.  Reacting to changes in connectivity is a crucial part of providing good real-time transport.
        </p>
        <p>
          The <code><dfn>networkchange</dfn></code> event is registered against a local <code><a>RealtimePort</a></code>.
        </p>
        <p class="note">
          Ideally, this would be globally registered, but since events can't originate on static objects, this is difficult.  Again, ideally this is something for the <a href="http://www.w3.org/TR/netinfo-api/">network information API</a> to solve.
        </p>
        <p>
          The browser fires a <code><a>networkchange</a></code> event when it detects a potential change in the status of the network.  Events that trigger this callback include changes to open network interfaces and the addition or removal of network interfaces.
        </p>
      </section>

      <section>
        <h3>Privacy Considerations</h3>
        <p>
          Applications that establish peer-to-peer transports require that the IP addresses of a peer are signaled to the remote peer.  This can pose a privacy exposure even though an IP address can only be loosely correlated with a person.  For instance, it is possible to use IP addresses to determine the physical location of a person.
        </p>
        <p>
          In some applications, establishing a peer-to-peer transport occurs prior to establishing user consent for the session.  This can be necessary to remove the delays associated with transport setup that might otherwise occur after session acceptance.  Exposing IP address information prior to acceptance provides the initiator of the session a way to collect the IP address of even an unwilling peer.
        </p>
        <p>
          Applications are encouraged to only signal relay ports prior to gaining explicit consent from users.
        </p>
      </section>
    </section>
    
    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        Travis Leithead provided guidance on modern web API design that was invaluable.  Tim Moore provided input on mapping media to RTP streams.
      </p>
    </section>
</html>
